<div class="flexContainer">
    <mat-accordion id="contentList" displayMode="flat" style="padding-left: 5px; padding-right: 5px;">
        <mat-expansion-panel style="margin-top: 5px;">
            <mat-expansion-panel-header>
                <mat-panel-title>
                    C++ Part2
                </mat-panel-title>
            </mat-expansion-panel-header>
            <button mat-button class="listItem" (click)="scrollTo('chapter9')">Chapter 9: Compound Types</button>
            <button mat-button class="listItem" (click)="scrollTo('chapter10')">Chapter 10: Arrays, Strings, Pointers, and References</button>
        </mat-expansion-panel>
    </mat-accordion>
    <div fxLayout="column" fxLayout="column">
        <div>
            <h1>C++ Part2</h1>
            <h2>Introduction</h2>
            <p>The following are mainly the notes summarized from <a href="https://www.learncpp.com/" target="_blank" rel="noopener noreferrer">learncpp.com</a>.</p>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter9">
            <h2>Chapter 9: Compound Types</h2>
            <ul>
                <li>Enumerated types</li>
                    <ul>
                        <li>An <strong>enumerated type</strong> (also called an <strong>enumeration</strong> or <strong>enum</strong>) is a data type where every possible value is defined as a symbolic constant (called an enumerator).</li>
                        <li>The following is an example of enum. By default, the enumerators are automatically assigned with integers starting from 0.</li>
                            <pre>
                                <code>
    enum TrafficLightColor &#123;
        green,  // automatically assigned 0
        yellow, // automatically assigned 1
        red     // automatically assigned 2
    };
                                </code>
                            </pre>
                        <li>Enum is NOT type safe because the enumerators are not scoped. The following code will have redefinition error.</li>
                            <pre>
                                <code>
    std::string green = "green"; // let's say we declare a variable called "green"
    enum TrafficLightColor &#123;
        green,  // will have redefinition error
        yellow, 
        red    
    };
                                </code>
                            </pre>
                        <li>Hence, C++ 11 introduces <strong>enum class</strong> concept. To make an enum class, simply add the <strong>class</strong> keyword after the enum keyword.</li>
                            <pre>
                                <code>
    enum class TrafficLightColor &#123;
        green,
        yellow, 
        red    
    };
                                </code>
                            </pre>
                        <li>Use case example of enum class</li>
                            <pre>
                                <code>
    #include &lt;iostream>
    #include &lt;string>
    
    enum class TrafficLightColor &#123;
        green,  // assigned 0
        yellow, // assigned 1
        red     // assigned 2
    };
    
    // instead of "int getTrafficLightStatus()"
    TrafficLightColor getTrafficLightStatus() &#123;
        return TrafficLightColor::green;
    }
    
    // instead of "void displayLight(int color)"
    void displayLight(TrafficLightColor color) &#123;
        if (color == TrafficLightColor::green) &#123;
            std::cout &lt;&lt; "green" &lt;&lt; '\n';
        }
        else if (color == TrafficLightColor::yellow) &#123;
            std::cout &lt;&lt; "yellow" &lt;&lt; '\n';
        }
        else if (color == TrafficLightColor::red) &#123;
            std::cout &lt;&lt; "red" &lt;&lt; '\n';
        }
    }

    int main() &#123;
        displayLight(getTrafficLightStatus());                       // output: "green"
        TrafficLightColor nextColor&#123; TrafficLightColor::yellow };    // variable declaration example
        std::cout &lt;&lt; static_cast&lt;int>(nextColor) &lt;&lt; '\n';            // output : 1
        displayLight(nextColor);                                     // output: "yellow"
        return 0;
    }
                                </code>
                            </pre>
                    </ul>
                <li>struct</li>
                    <ul>
                        <li>A <strong>struct</strong> allows us to group variables of mixed types together into a single unit.</li>
                        <li>The variables that are part of the struct are called <strong>members</strong>.</li>
                        <li>An example of struct:</li>
                            <pre>
                                <code>
    struct Employee &#123;
        int id&#123;};
        int age&#123;};
        bool isPermanent&#123;};
        double wage&#123;};
    };

    Employee john; 
    john.id = 1234;
    john.age = 32;
    john.wage = 24;
    john.isPermanent = false;
    Employee jack&#123; 1122, 20, 18, false };
                                </code>
                            </pre>
                        <li>We can set default value for the non-static struct members:</li>
                            <pre>
                                <code>
    struct Rectangle &#123;
        double length&#123; 1.0 };
        double width&#123; 1.0 };
    };
    Rectangle rectangleA&#123;}; // length = 1.0, width = 1.0
    Rectangle rectangleB&#123; 1.2 }; // length = 1.2, width = 1.0
                                </code>
                            </pre>
                        <li>We can also pass the entire struct as argument to a function.</li>
                            <pre>
                                <code>
    void printInformation(Employee employee) &#123;
        std::cout &lt;&lt; "ID:   " &lt;&lt; employee.id &lt;&lt; '\n';
        std::cout &lt;&lt; "Age:  " &lt;&lt; employee.age &lt;&lt; '\n';
        std::cout &lt;&lt; "Wage: " &lt;&lt; employee.wage &lt;&lt; '\n';
    }
                                </code>
                            </pre>
                        <li>A struct can be used as return type of function as well.</li>
                            <pre>
                                <code>
    struct Point3d &#123;
        double x&#123;};
        double y&#123;};
        double z&#123;};
    };

    Point3d getZeroPoint() &#123;
        // We can create a variable and return the variable.
        Point3d temp &#123; 0.0, 0.0, 0.0 };
        return temp;
    }
                                </code>
                            </pre>
                        <li>Nested structs are also possible.</li>
                            <pre>
                                <code>
    struct Employee &#123;
        int id&#123;};
        int age&#123;};
        double wage&#123;};
    };

    struct Company &#123;
        Employee CEO&#123;}; // Employee is a struct within the Company struct
        int numberOfEmployees&#123;};
    };

    Company companyA&#123;&#123;0001, 52, 999}, 1000};
    std::cout &lt;&lt; companyA.CEO.wage &lt;&lt; '\n';
                                </code>
                            </pre>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter10">
            <h2>Chapter 10: Arrays, Strings, Pointers, and References</h2>
            <ul>
                <li>Arrays</li>
                    <ul>
                        <li>Assuming you already have the basic understanding of arrays, so they are not covered here.</li>
                        <li>Arrays can be made from structs.</li>
                            <pre>
                                <code>
    struct Rectangle &#123;
        int length&#123;};
        int width&#123;};
    };
    Rectangle rects[5]&#123;}; // declare an array of 5 Rectangle
    std::cout &lt;&lt; rects[0].length &lt;&lt; '\n';
                                </code>
                            </pre>
                        <li>When declaring a fixed array, the length of the array must be a compile-time constant. For "array" with dynamic size, 
                            refer to C++ <a href="https://www.cplusplus.com/reference/vector/vector/" target="_blank" rel="noopener noreferrer">vector</a>.</li>
                        <li>To initlize the elements of a fixed array, we can use initializer list. 
                            If there are less initializers than the size of array, the rest of of the elements are initialized to zero.
                            If you didnt declare the length of an array, the compiler will set the length of array based on length of initializer list. 
                        </li>
                            <pre>
                                <code>
    int prime[5]&#123; 2, 3, 5, 7, 11 }; // use initializer list to initialize the fixed array
    int arrayA[10]&#123; 1, 2, 3}; // the rest of the elments are initilized to zero
    int arrayB[]&#123;0, 1, 2, 3, 4, 5} // let the initializer list set length of the array
                                </code>
                            </pre>
                        <li>Use a enum inside of a namespace, and then use it to map the elements of array.</li>
                            <pre>
                                <code>
    namespace StudentNames &#123;
        enum StudentNames &#123;
            kenny, // 0
            kyle, // 1
            stan, // 2
            butters, // 3
            cartman, // 4
            wendy, // 5
        };
    }

    int main() &#123;
        int testScores[5]&#123;}; 
        testScores[StudentNames::stan] = 76;
        return 0;
    }
                                </code>
                            </pre>
                        <li>Passing arrays to functions</li>
                            <ul>
                                <li>When a normal variable is passed by value, C++ copies the value of the argument into the function parameter.
                                    Hence, modifying the value of the parameter will not affect the original argument.</li>
                                <li>HOWEVER, <strong>when an array is passed into a function, the actual array is passed.</strong>.
                                    Hence, modifying the elements of array inside the function will also affect the original argument which is
                                    out of the function.</li>
                            </ul>
                        <li>To swap values of two variables, we can use the std::swap() function from C++ standard library. 
                            This function can be used for swapping elements of array as well.</li>
                        <li>To sort elements of array, we can use some algorithms such as bubble sort, selection sort and insertion sort.
                            But C++ standard library has a sorting function named std::sort() as well.</li>
                            <pre>
                                <code>
    #include &lt;iostream>
    #include &lt;iterator> // for std::size
    #include &lt;algorithm> // for std::sort
    
    int main()
    &#123;
        int array[]&#123; 10, 1, 22, 31, 5, 8, 3, 21 };
        std::sort(std::begin(array), std::end(array));
        for (int i = 0; i &lt; std::size(array); i++) &#123;
            std::cout &lt;&lt; array[i] &lt;&lt; '\n';
        }
        return 0;
    }
                                </code>
                            </pre>
                    </ul>
                <li>C-style Strings</li>
                    <ul>
                        <li>Other than std::string, C++ does support C-style Strings.</li>
                        <li>C-style string is an array of characters that uses a null terminator.</li>
                        <li><strong>Best practice: </strong>Use std::string instead of C-style strings.</li>
                        <li>Since C-style Strings are not preferred, they are not covered here.</li>
                    </ul>
                <li>Pointers</li>
                    <ul>
                        <li>The <strong>address-of operator (&)</strong> allows us to see what memory address is assigned to a variable.</li>
                        <li>The <strong>indirection operator (*)</strong> (also called <strong>dereference operator</strong>) allows us to access the value at a particular address:</li>
                        <li>A <strong>pointer</strong> is a variable that holds a memory address as its value.</li>
                        <pre>
                            <code>
    int x&#123; 5 };
    int* ptrX&#123;&x}; // initialize ptrX with address of vqriable x
    std::cout &lt;&lt; x &lt;&lt; '\n'; // print the value of variable x
    std::cout &lt;&lt; &x &lt;&lt; '\n'; // print the memory address of variable x
    std::cout &lt;&lt; ptrX &lt;&lt; '\n'; // print the address that ptrX is holding
    std::cout &lt;&lt; *(&x) &lt;&lt; '\n'; /// print the value at the memory address of variable x (parenthesis is optional)                            
                            </code>
                        </pre>
                        <li>Pointers are useful in many cases, but they will be covered in future chapters.</li>
                    </ul>
                <li>Null pointer</li>
                    <ul>
                        <li>A pointer holding a null value is called a <strong>null pointer</strong>.</li>
                        <li>In C++ 11, we can assign a pointer a null value by using the <strong>nullptr</strong> keyword:</li>
                            <ul>
                                <li>Example: float* ptr &#123; nullptr };  // ptr is now a null pointer</li>
                            </ul>
                        <li><strong>Best practice: </strong>Use nullptr to initialize your pointers to a null value if you’re not giving them another value.</li>
                        <li>C++ 11 also introduces a new type called std::nullptr_t (in header &lt;cstddef>), and it can only hold one value: nullptr.</li>
                    </ul>
                <li>Pointers and arrays</li>
                    <ul>
                        <li>In C++, when a fixed array is used in an expression, the fixed array will decay (be implicitly converted) into a pointer that points to the first element of the array.</li>
                            <pre>
                                <code>
    int array[5]&#123; 9, 7, 5, 3, 1 };

    // print address of the array's first element
    std::cout &lt;&lt; "Element 0 has address: " &lt;&lt; &array[0] &lt;&lt; '\n'; // example output: 0000008D7995FC54

    // print the value of the pointer the array decays to
    std::cout &lt;&lt; "The array decays to a pointer holding address: " &lt;&lt; array &lt;&lt; '\n'; // example output: 0000008D7995FC54
                                </code>
                            </pre>
                        <li>Hence, the following 2 function declarations are identical:</li>
                            <pre>
                                <code>
    void printSize(int array[]);
    void printSize(int* array); // this is lightly recommended as it makes clear that the parameter is being treated as a pointer
                                </code>
                            </pre>
                        <li>A side note is arrays in structs and classes don’t decay. This yields a useful way to prevent decay if desired, and will be valuable later when we write classes that utilize arrays.</li>
                    </ul>
                <li>Pointer arithmetic and array indexing</li>
                    <ul>
                        <li>If we have a pointer called 'ptr', then ptr + 1 then will return the memory address of the next object of the type that ptr points to.</li>
                            <pre>
                                <code>
    short value&#123; 7 }; // short is 2 bytes
    short* ptr&#123; &value };
    std::cout &lt;&lt; ptr &lt;&lt; '\n'; // If this points to 00000039785AF98A
    std::cout &lt;&lt; ptr+1 &lt;&lt; '\n'; // then this one will point to 2 bytes after ptr, which is 00000039785AF98C
                                </code>
                            </pre>
                        <li>Arrays are laid out sequentially in memory, and that is why we can use iterator to traverse through an array easily.</li>
                        <li>array[n] is equivalent to *(array + n), where n is an integer. The (array + n) points to the nth element of an array,
                            and hence deferencing it with * will get the value of nth element in that array.</li>
                        <li>Side Note: the algorithms library offers std::count_if, which counts elements that fulfill a condition.
                            We can also make use of std::begin to point to the first element of array, and then use std::end to point to the object AFTER the last element.</li>
                            <pre>
                                <code>
    #include &lt;iostream>
    #include &lt;algorithm> // for std::count_if
    #include &lt;iterator> // for std::begin and std::end
    
    bool isO(char ch) &#123;
        switch (ch) &#123;
            case 'O':
            case 'o':
                return true;
            default:
                return false;
        }
    }
    char sampleText[]&#123; "hello world" };
    auto numOfO&#123; std::count_if(std::begin(sampleText), std::end(sampleText), isO) };
    std::cout &lt;&lt; numOfO &lt;&lt; '\n';
                                </code>
                            </pre>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div>
    </div>
    <div (click)="scrollTo('contentList')" class="floatingIconDiv">
        <fa-icon  [icon]="faArrowAltCircleUp" size="2x"></fa-icon>
    </div>
</div>