<div class="flexContainer">
    <mat-accordion id="contentList" displayMode="flat" style="padding-left: 5px; padding-right: 5px;">
        <mat-expansion-panel style="margin-top: 5px;">
            <mat-expansion-panel-header>
                <mat-panel-title>
                    C++ Part2
                </mat-panel-title>
            </mat-expansion-panel-header>
            <button mat-button class="listItem" (click)="scrollTo('chapter9')">Chapter 9: Compound Types</button>
            <button mat-button class="listItem" (click)="scrollTo('chapter10')">Chapter 10: Arrays, Strings, Pointers, and References</button>
        </mat-expansion-panel>
    </mat-accordion>
    <div fxLayout="column" fxLayout="column">
        <div>
            <h1>C++ Part2</h1>
            <h2>Introduction</h2>
            <p>The following are mainly the notes summarized from <a href="https://www.learncpp.com/" target="_blank" rel="noopener noreferrer">learncpp.com</a>.</p>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter9">
            <h2>Chapter 9: Compound Types</h2>
            <ul>
                <li>Enumerated types</li>
                    <ul>
                        <li>An <strong>enumerated type</strong> (also called an <strong>enumeration</strong> or <strong>enum</strong>) is a data type where every possible value is defined as a symbolic constant (called an enumerator).</li>
                        <li>The following is an example of enum. By default, the enumerators are automatically assigned with integers starting from 0.</li>
                            <pre>
                                <code>
    enum TrafficLightColor &#123;
        green,  // automatically assigned 0
        yellow, // automatically assigned 1
        red     // automatically assigned 2
    };
                                </code>
                            </pre>
                        <li>Enum is NOT type safe because the enumerators are not scoped. The following code will have redefinition error.</li>
                            <pre>
                                <code>
    std::string green = "green"; // let's say we declare a variable called "green"
    enum TrafficLightColor &#123;
        green,  // will have redefinition error
        yellow, 
        red    
    };
                                </code>
                            </pre>
                        <li>Hence, C++ 11 introduces <strong>enum class</strong> concept. To make an enum class, simply add the <strong>class</strong> keyword after the enum keyword.</li>
                            <pre>
                                <code>
    enum class TrafficLightColor &#123;
        green,
        yellow, 
        red    
    };
                                </code>
                            </pre>
                        <li>Use case example of enum class</li>
                            <pre>
                                <code>
    #include &lt;iostream>
    #include &lt;string>
    
    enum class TrafficLightColor &#123;
        green,  // assigned 0
        yellow, // assigned 1
        red     // assigned 2
    };
    
    // instead of "int getTrafficLightStatus()"
    TrafficLightColor getTrafficLightStatus() &#123;
        return TrafficLightColor::green;
    }
    
    // instead of "void displayLight(int color)"
    void displayLight(TrafficLightColor color) &#123;
        if (color == TrafficLightColor::green) &#123;
            std::cout &lt;&lt; "green" &lt;&lt; '\n';
        }
        else if (color == TrafficLightColor::yellow) &#123;
            std::cout &lt;&lt; "yellow" &lt;&lt; '\n';
        }
        else if (color == TrafficLightColor::red) &#123;
            std::cout &lt;&lt; "red" &lt;&lt; '\n';
        }
    }

    int main() &#123;
        displayLight(getTrafficLightStatus());                       // output: "green"
        TrafficLightColor nextColor&#123; TrafficLightColor::yellow };    // variable declaration example
        std::cout &lt;&lt; static_cast&lt;int>(nextColor) &lt;&lt; '\n';            // output : 1
        displayLight(nextColor);                                     // output: "yellow"
        return 0;
    }
                                </code>
                            </pre>
                    </ul>
                <li>struct</li>
                    <ul>
                        <li>A <strong>struct</strong> allows us to group variables of mixed types together into a single unit.</li>
                        <li>The variables that are part of the struct are called <strong>members</strong>.</li>
                        <li>An example of struct:</li>
                            <pre>
                                <code>
    struct Employee &#123;
        int id&#123;};
        int age&#123;};
        bool isPermanent&#123;};
        double wage&#123;};
    };

    Employee john; 
    john.id = 1234;
    john.age = 32;
    john.wage = 24;
    john.isPermanent = false;
    Employee jack&#123; 1122, 20, 18, false };
                                </code>
                            </pre>
                        <li>We can set default value for the non-static struct members:</li>
                            <pre>
                                <code>
    struct Rectangle &#123;
        double length&#123; 1.0 };
        double width&#123; 1.0 };
    };
    Rectangle rectangleA&#123;}; // length = 1.0, width = 1.0
    Rectangle rectangleB&#123; 1.2 }; // length = 1.2, width = 1.0
                                </code>
                            </pre>
                        <li>We can also pass the entire struct as argument to a function.</li>
                            <pre>
                                <code>
    void printInformation(Employee employee) &#123;
        std::cout &lt;&lt; "ID:   " &lt;&lt; employee.id &lt;&lt; '\n';
        std::cout &lt;&lt; "Age:  " &lt;&lt; employee.age &lt;&lt; '\n';
        std::cout &lt;&lt; "Wage: " &lt;&lt; employee.wage &lt;&lt; '\n';
    }
                                </code>
                            </pre>
                        <li>A struct can be used as return type of function as well.</li>
                            <pre>
                                <code>
    struct Point3d &#123;
        double x&#123;};
        double y&#123;};
        double z&#123;};
    };

    Point3d getZeroPoint() &#123;
        // We can create a variable and return the variable.
        Point3d temp &#123; 0.0, 0.0, 0.0 };
        return temp;
    }
                                </code>
                            </pre>
                        <li>Nested structs are also possible.</li>
                            <pre>
                                <code>
    struct Employee &#123;
        int id&#123;};
        int age&#123;};
        double wage&#123;};
    };

    struct Company &#123;
        Employee CEO&#123;}; // Employee is a struct within the Company struct
        int numberOfEmployees&#123;};
    };

    Company companyA&#123;&#123;0001, 52, 999}, 1000};
    std::cout &lt;&lt; companyA.CEO.wage &lt;&lt; '\n';
                                </code>
                            </pre>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter10">
            <h2>Chapter 10: Arrays, Strings, Pointers, and References</h2>
            <ul>
                <li>Arrays</li>
                    <ul>
                        <li>Assuming you already have the basic understanding of arrays, so they are not covered here.</li>
                        <li>Arrays can be made from structs.</li>
                            <pre>
                                <code>
    struct Rectangle &#123;
        int length&#123;};
        int width&#123;};
    };
    Rectangle rects[5]&#123;}; // declare an array of 5 Rectangle
    std::cout &lt;&lt; rects[0].length &lt;&lt; '\n';
                                </code>
                            </pre>
                        <li>When declaring a fixed array, the length of the array must be a compile-time constant. For "array" with dynamic size, 
                            refer to C++ <a href="https://www.cplusplus.com/reference/vector/vector/" target="_blank" rel="noopener noreferrer">vector</a>.</li>
                        <li>To initlize the elements of a fixed array, we can use initializer list. 
                            If there are less initializers than the size of array, the rest of of the elements are initialized to zero.
                            If you didnt declare the length of an array, the compiler will set the length of array based on length of initializer list. 
                        </li>
                            <pre>
                                <code>
    int prime[5]&#123; 2, 3, 5, 7, 11 }; // use initializer list to initialize the fixed array
    int arrayA[10]&#123; 1, 2, 3}; // the rest of the elments are initilized to zero
    int arrayB[]&#123;0, 1, 2, 3, 4, 5} // let the initializer list set length of the array
                                </code>
                            </pre>
                        <li>Use a enum inside of a namespace, and then use it to map the elements of array.</li>
                            <pre>
                                <code>
    namespace StudentNames &#123;
        enum StudentNames &#123;
            kenny, // 0
            kyle, // 1
            stan, // 2
            butters, // 3
            cartman, // 4
            wendy, // 5
        };
    }

    int main() &#123;
        int testScores[5]&#123;}; 
        testScores[StudentNames::stan] = 76;
        return 0;
    }
                                </code>
                            </pre>
                        <li>Passing arrays to functions</li>
                            <ul>
                                <li>When a normal variable is passed by value, C++ copies the value of the argument into the function parameter.
                                    Hence, modifying the value of the parameter will not affect the original argument.</li>
                                <li>HOWEVER, <strong>when an array is passed into a function, the actual array is passed.</strong>.
                                    Hence, modifying the elements of array inside the function will also affect the original argument which is
                                    out of the function.</li>
                            </ul>
                        <li>To swap values of two variables, we can use the std::swap() function from C++ standard library. 
                            This function can be used for swapping elements of array as well.</li>
                        <li>To sort elements of array, we can use some algorithms such as bubble sort, selection sort and insertion sort.
                            But C++ standard library has a sorting function named std::sort() as well.</li>
                            <pre>
                                <code>
    #include &lt;iostream>
    #include &lt;iterator> // for std::size
    #include &lt;algorithm> // for std::sort
    
    int main()
    &#123;
        int array[]&#123; 10, 1, 22, 31, 5, 8, 3, 21 };
        std::sort(std::begin(array), std::end(array));
        for (int i = 0; i &lt; std::size(array); i++) &#123;
            std::cout &lt;&lt; array[i] &lt;&lt; '\n';
        }
        return 0;
    }
                                </code>
                            </pre>
                    </ul>
                <li>C-style Strings</li>
                    <ul>
                        <li>Other than std::string, C++ does support C-style Strings. And actually std::string is implemented using C-style strings</li>
                        <li>C-style string is an array of characters that uses a null terminator.</li>
                        <li><strong>Best practice: </strong>Use std::string instead of C-style strings.</li>
                        <li>Since C-style Strings are not preferred, they are not covered here.</li>
                    </ul>
                <li>Pointers</li>
                    <ul>
                        <li>The <strong>address-of operator (&)</strong> allows us to see what memory address is assigned to a variable.</li>
                        <li>The <strong>indirection operator (*)</strong> (also called <strong>dereference operator</strong>) allows us to access the value at a particular address:</li>
                        <li>A <strong>pointer</strong> is a variable that holds a memory address as its value.</li>
                        <pre>
                            <code>
    int x&#123; 5 };
    int* ptrX&#123;&x}; // initialize ptrX with address of vqriable x
    std::cout &lt;&lt; x &lt;&lt; '\n'; // print the value of variable x
    std::cout &lt;&lt; &x &lt;&lt; '\n'; // print the memory address of variable x
    std::cout &lt;&lt; ptrX &lt;&lt; '\n'; // print the address that ptrX is holding
    std::cout &lt;&lt; *(&x) &lt;&lt; '\n'; /// print the value at the memory address of variable x (parenthesis is optional)                            
                            </code>
                        </pre>
                        <li>Pointers are useful in many cases, but they will be covered in future chapters.</li>
                    </ul>
                <li>Null pointer</li>
                    <ul>
                        <li>A pointer holding a null value is called a <strong>null pointer</strong>.</li>
                        <li>In C++ 11, we can assign a pointer a null value by using the <strong>nullptr</strong> keyword:</li>
                            <ul>
                                <li>Example: float* ptr &#123; nullptr };  // ptr is now a null pointer</li>
                            </ul>
                        <li><strong>Best practice: </strong>Use nullptr to initialize your pointers to a null value if you’re not giving them another value.</li>
                        <li>C++ 11 also introduces a new type called std::nullptr_t (in header &lt;cstddef>), and it can only hold one value: nullptr.</li>
                    </ul>
                <li>Pointers and arrays</li>
                    <ul>
                        <li>In C++, when a fixed array is used in an expression, the fixed array will decay (be implicitly converted) into a pointer that points to the first element of the array.</li>
                            <pre>
                                <code>
    int array[5]&#123; 9, 7, 5, 3, 1 };

    // print address of the array's first element
    std::cout &lt;&lt; "Element 0 has address: " &lt;&lt; &array[0] &lt;&lt; '\n'; // example output: 0000008D7995FC54

    // print the value of the pointer the array decays to
    std::cout &lt;&lt; "The array decays to a pointer holding address: " &lt;&lt; array &lt;&lt; '\n'; // example output: 0000008D7995FC54
                                </code>
                            </pre>
                        <li>Hence, the following 2 function declarations are identical:</li>
                            <pre>
                                <code>
    void printSize(int array[]);
    void printSize(int* array); // this is lightly recommended as it makes clear that the parameter is being treated as a pointer
                                </code>
                            </pre>
                        <li>A side note is arrays in structs and classes don’t decay. This yields a useful way to prevent decay if desired, and will be valuable later when we write classes that utilize arrays.</li>
                    </ul>
                <li>Pointer arithmetic and array indexing</li>
                    <ul>
                        <li>If we have a pointer called 'ptr', then ptr + 1 then will return the memory address of the next object of the type that ptr points to.</li>
                            <pre>
                                <code>
    short value&#123; 7 }; // short is 2 bytes
    short* ptr&#123; &value };
    std::cout &lt;&lt; ptr &lt;&lt; '\n'; // If this points to 00000039785AF98A
    std::cout &lt;&lt; ptr+1 &lt;&lt; '\n'; // then this one will point to 2 bytes after ptr, which is 00000039785AF98C
                                </code>
                            </pre>
                        <li>Arrays are laid out sequentially in memory, and that is why we can use iterator to traverse through an array easily.</li>
                        <li>array[n] is equivalent to *(array + n), where n is an integer. The (array + n) points to the nth element of an array,
                            and hence deferencing it with * will get the value of nth element in that array.</li>
                        <li>Side Note: the algorithms library offers std::count_if, which counts elements that fulfill a condition.
                            We can also make use of std::begin to point to the first element of array, and then use std::end to point to the object AFTER the last element.</li>
                            <pre>
                                <code>
    #include &lt;iostream>
    #include &lt;algorithm> // for std::count_if
    #include &lt;iterator> // for std::begin and std::end
    
    bool isO(char ch) &#123;
        switch (ch) &#123;
            case 'O':
            case 'o':
                return true;
            default:
                return false;
        }
    }
    char sampleText[]&#123; "hello world" }; // using std::string sampleText&#123; "hello world" } is also the same
    auto numOfO&#123; std::count_if(std::begin(sampleText), std::end(sampleText), isO) };
    std::cout &lt;&lt; numOfO &lt;&lt; '\n';
                                </code>
                            </pre>
                    </ul>
                <li>C-style string symbolic constant is not covered here.</li>
                <li>Dynamic memory allocation with new and delete</li>
                    <ul>
                        <li>C++ supports 3 basic types of memory allocation</li>
                            <ul>
                                <li><strong>Static memory allocation</strong> happens for static and global variables.
                                    Memory for these types of variables is allocated once when your program is run and persists throughout the life of your program.</li>
                                <li><strong>Automatic memory allocation</strong> happens for function parameters and local variables.
                                    Memory for these types of variables is allocated when the relevant block is entered, and freed when the block is exited, as many times as necessary.</li>
                                <li><strong>Dynamic memory allocation</strong> is a way for running programs to request memory from the operating system when needed. 
                                    This memory does not come from the program’s limited stack memory -- instead, it is allocated from a much larger pool of memory managed by the operating system called the <strong>heap</strong>. 
                                    On modern machines, the heap can be gigabytes in size.</li>
                            </ul>
                        <li>Both static and automatic allocation have two things in common:</li>
                            <ul>
                                <li>The size of the variable / array must be known at compile time.</li>
                                <li>Memory allocation and deallocation happens automatically (when the variable is instantiated / destroyed).</li>
                            </ul>
                        <li>Dynamically allocating single variables</li>
                            <ul>
                                <li>To allocate a single variable dynamically, we use the scalar (non-array) form of the new operator. The new operator creates the object using that memory, and then returns a pointer containing the address of the memory that has been allocated.</li>
                                    <pre>
                                        <code>
    int* ptr&#123; new int }; // dynamically allocate an integer and assign the address to ptr so we can access it later
    *ptr = 7; // assign value of 7 to allocated memory

    int* ptr2&#123; new int &#123; 6 } }; // use uniform initialization
                                        </code>
                                    </pre>
                            </ul>
                        <li>When you dynamically allocate memory,</li>
                            <ul>
                                <li>You’re asking the operating system to reserve some memory for your program’s use.</li>
                                <li>If it can fulfill this request, it will return the address of that memory to your application.</li>
                                <li>From that point forward, your application can use this memory as it wishes. </li>
                                <li>When your application is done with the memory, it can return the memory back to the operating system to be given to another program.</li>
                            </ul>
                        <li>You may free a memory for reuse by using the <strong>delete</strong> operator.
                             Note that the delete operator doesn't actually delete anything, it simply returns the memory being pointed to back to the operating system.
                            However, after freeing the memory, remember to set the pointer to nullptr.</li>
                            <pre>
                                <code>
    // assume ptr has previously been allocated with operator new
    delete ptr; // return the memory pointed to by ptr to the operating system
    ptr = nullptr; // set ptr to be a null pointer
                                </code>
                            </pre>
                        <li>Memory leaks</li>
                            <ul>
                                <li>Dynamically allocated memory stays allocated until it is explicitly deallocated or until the program ends.</li>
                                <li>However, the pointers used to hold dynamically allocated memory addresses follow the normal scoping rules for local variables.</li>
                                <li>Consider the following:</li>
                                    <pre>
                                        <code>
    void doSomething() &#123;
        int* ptr&#123; new int&#123;} };
    }
                                        </code>
                                    </pre>
                                <li>Because pointers variables are just normal variables, when the function ends, ptr will go out of scope.</li>
                                <li>Then, ptr is destroyed there are no more references to the dynamically allocated memory.</li>
                                <li>Now, the memory address is allocated but now we dont have any reference to that memory address, and hence we can't free the memory address.</li>
                                <li>This is called a <strong>memory leak</strong>, which means your program loses the address of some bit of dynamically allocated memory before giving it back to the operating system. </li>
                                <li>Memory leaks will eat up your free memory while the program is running.</li>
                                <li>The following 2 cases will also result in memory leaks:</li>
                                    <pre>
                                        <code>
    // CASE 1 - a pointer is assigned another value
    int value = 5;
    int* ptr&#123; new int&#123;} }; // allocate memory
    ptr = &amp;value; // old address lost, memory leak results

    // CASE 2 - double-allocation
    int* ptr&#123; new int&#123;} };
    ptr = new int&#123;}; // old address lost, memory leak results
                                        </code>
                                    </pre>
                                <li>The solution for memory leaks would be deleting or freeing the pointer before it is out of scope or before assigning new value to it.</li>
                            </ul>
                    </ul>
                <li>Pointers and const</li>
                    <ul>
                        <li>A non-const pointer can be redirected to point to other addresses.</li>
                        <li>A const pointer always points to the same address, and this address can not be changed.</li>
                        <li>A pointer to a non-const value can change the value it is pointing to. These can not point to a const value.</li>
                        <li>A pointer to a const value treats the value as const (even if it is not), and thus can not change the value it is pointing to.</li>
                        <pre>
                            <code>
    int value&#123; 5 };
    const int* ptr1&#123; &value }; // ptr1 points to a "const int", so this is a pointer to a const value.
    int* const ptr2&#123; &value }; // ptr2 points to an "int", so this is a const pointer to a non-const value.
    const int* const ptr3&#123; &value }; // ptr3 points to a "const int", so this is a const pointer to a const value.
                            </code>
                        </pre>
                    </ul>
                <li>Reference variables</li>
                    <ul>
                        <li>Other than normal variables and pointers, C++ also supports another type of variables - references.</li>
                        <li>A <strong>reference</strong> is a C++ variable that acts as an alias to another object or value, 
                            and it acts identically to the value it is referencing.</li>
                            <pre>
                                <code>
    int value&#123; 5 }; // normal integer
    int& y&#123; x }; // y is a reference to variable x
    int& z&#123; y }; // z is also a reference to variable x
                                </code>
                            </pre>
                        <li>In the above snippet, setting or getting the value of x, y, or z will all do the same thing (set or get the value of x).
                            The address of the references also same with the variable that they are referencing.
                        </li>
                            <pre>
                                <code>
    int x&#123; 5 }; // normal integer
    int& y&#123; x }; // y is a reference to variable m
    int& z&#123; y }; // z is also a reference to variable m
    std::cout &lt;&lt; x &lt;&lt; '\n'; // output: 5
    std::cout &lt;&lt; y &lt;&lt; '\n'; // output: 5
    std::cout &lt;&lt; z &lt;&lt; '\n'; // output: 5
    x = 6;
    std::cout &lt;&lt; x &lt;&lt; '\n'; // output: 6
    std::cout &lt;&lt; y &lt;&lt; '\n'; // output: 6
    std::cout &lt;&lt; z &lt;&lt; '\n'; // output: 6
    ++z;
    std::cout &lt;&lt; x &lt;&lt; '\n'; // output: 7
    std::cout &lt;&lt; y &lt;&lt; '\n'; // output: 7
    std::cout &lt;&lt; z &lt;&lt; '\n'; // output: 7

    std::cout &lt;&lt; &x &lt;&lt; '\n'; // output: 000000614ABDF5A4
    std::cout &lt;&lt; &y &lt;&lt; '\n'; // output: 000000614ABDF5A4
    std::cout &lt;&lt; &z &lt;&lt; '\n'; // output: 000000614ABDF5A4
                                </code>
                            </pre>
                        <li>Referencces must be initialized to a variable value, there is NO such thing as a null reference.</li>
                        <li>Once initialized, a reference can not be changed to reference another variable. </li>
                        <li>References are most often used as function parameters.</li>
                            <ul>
                                <li>In this context, the reference parameter acts as an alias for the argument, and no copy of the argument is made into the parameter.</li>
                                <li>This can lead to better performance if the argument is large or expensive to copy.</li>
                                <li>Example:</li>
                                    <pre>
                                        <code>
    // ref is a reference to the argument passed in, not a copy
    void setNumTo6(int& ref) &#123;
        ref = 6;
    }

    int main () &#123;
        int num&#123; 5 };
        setNumTo6(num);
        std::cout &lt;&lt; num &lt;&lt; '\n'; // output: 6
        return 0;
    }               
                                        </code>
                                    </pre>
                            </ul>
                        <li><strong>Best practice: </strong>Pass arguments by non-const reference (rather than by pointer) when the argument needs to be modified by the function, 
                        applicable for variables that are not pointers or non-fundamental data types (such as structs). Fundametal data types such as int, double etc should be passed by value.</li>
                        <li>References vs pointers</li>
                            <ul>
                                <li>References and pointers have an interesting relationship -- a reference acts like a pointer that implicitly performs indirection through it when accessed</li>
                                <li>Hence *ptr and ref are identical.</li>
                                <pre>
                                    <code>
    int valueB&#123; 5 };
    int* const ptrC&#123; &valueB };
    int& refD&#123; valueB };
    std::cout &lt;&lt; *ptrC &lt;&lt; '\n'; // output: 5
    std::cout &lt;&lt; refD &lt;&lt; '\n'; // output: 5
    *ptrC = 6;
    std::cout &lt;&lt; *ptrC &lt;&lt; '\n'; // output: 6
    std::cout &lt;&lt; refD &lt;&lt; '\n';  // output: 6
    refD = 7;
    std::cout &lt;&lt; *ptrC &lt;&lt; '\n'; // output: 7
    std::cout &lt;&lt; refD &lt;&lt; '\n';  // output: 7
                                    </code>
                                </pre>
                            </ul>
                        <li>References and const</li>
                            <ul>
                                <li>Much like a pointer to a const value, a reference to a const value can reference a non-const variable. When accessed through a reference to a const value, 
                                    the value is considered const even if the original variable is not:</li>
                                    <pre>
                                        <code>
    int apple&#123; 5 };
    const int& refApple&#123; apple }; // apple is not const, but refApple is still "a reference to const value"
    apple = 6;
    std::cout &lt;&lt; apple &lt;&lt; '\n'; //ouput: 6
    std::cout &lt;&lt; refApple &lt;&lt; '\n'; // output: 6
    // refApple = 7; // illegal -- refApple is const
    const int orange&#123; 3 };
    const int& refOrange&#123; orange }; // refOrange is also "a reference to const value"
    const int& refGrapes&#123; 8 }; //refGrapse is also "a reference to const value"                                        
                                        </code>
                                    </pre>
                                <li></li>
                            </ul>
                        <li>References used as function parameters can also be const.</li>
                            <ul>
                                <li>This allows us to access the argument without making a copy of it, while guaranteeing that the function will not change the value being referenced.</li>
                                <pre>
                                    <code>
    void printIt(const int& ref) &#123; // to guarantee the function will not change the value being referenced
        // ref = 6; // illegal -- ref is const
        std::cout &lt;&lt; ref;
    }
                                    </code>
                                </pre>
                            </ul>
                    </ul>
                <li>for-each loops</li>
                    <ul>
                        <li>The following is an example of for-each loop statement:</li>
                            <pre>
                                <code>
    constexpr int fibonacci[]&#123; 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 };
    for (int number : fibonacci) // iterate over array fibonacci
    &#123;
       std::cout &lt;&lt; number &lt;&lt; ' ';
    }
                                </code>
                            </pre>
                        <li>Since elements of the array should have the same type, it is suitable to use auto keyword to let compiler deduce the type.</li>
                        <li>Moreover, we can make use of reference to avoid copying array elements.</li>
                        <li>And if we are not going to modify the array elements, it's a good idea to make the reference const.</li>
                        <pre>
                            <code>
    std::string array[]&#123; "peter", "likes", "frozen", "yogurt" };
    for (const auto& element: array) // element is a const reference to the currently iterated array element
    &#123;
        std::cout &lt;&lt; element &lt;&lt; ' ';
    }
                            </code>
                        </pre>
                    </ul>
                <li>void pointer</li>
                    <ul>
                        <li>There is such thing called void pointer, but you ocassionally will use them. So this is not covered here.</li>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div>
    </div>
    <div (click)="scrollTo('contentList')" class="floatingIconDiv">
        <fa-icon  [icon]="faArrowAltCircleUp" size="2x"></fa-icon>
    </div>
</div>