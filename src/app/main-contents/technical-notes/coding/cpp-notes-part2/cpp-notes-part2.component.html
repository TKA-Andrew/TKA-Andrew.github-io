<div class="flexContainer">
    <mat-accordion id="contentList" displayMode="flat" style="padding-left: 5px; padding-right: 5px;">
        <mat-expansion-panel style="margin-top: 5px;">
            <mat-expansion-panel-header>
                <mat-panel-title>
                    C++ Part2
                </mat-panel-title>
            </mat-expansion-panel-header>
            <button mat-button class="listItem" (click)="scrollTo('chapter9')">Chapter 9: Compound Types</button>
            <button mat-button class="listItem" (click)="scrollTo('chapter10')">Chapter 10: Arrays, Strings, Pointers, and References</button>
            <button mat-button class="listItem" (click)="scrollTo('chapter11')">Chapter 11: Functions</button>
        </mat-expansion-panel>
    </mat-accordion>
    <div fxLayout="column">
        <div>
            <h1>C++ Part2</h1>
            <h2>Introduction</h2>
            <p>The following are mainly the notes summarized from <a href="https://www.learncpp.com/" target="_blank" rel="noopener noreferrer">learncpp.com</a>.</p>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter9">
            <h2>Chapter 9: Compound Types</h2>
            <ul>
                <li>Enumerated types</li>
                    <ul>
                        <li>An <strong>enumerated type</strong> (also called an <strong>enumeration</strong> or <strong>enum</strong>) is a data type where every possible value is defined as a symbolic constant (called an enumerator).</li>
                        <li>The following is an example of enum. By default, the enumerators are automatically assigned with integers starting from 0.</li>
                            <pre>
                                <code>
    enum TrafficLightColor &#123;
        green,  // automatically assigned 0
        yellow, // automatically assigned 1
        red     // automatically assigned 2
    };
                                </code>
                            </pre>
                        <li>Enum is NOT type safe because the enumerators are not scoped. The following code will have redefinition error.</li>
                            <pre>
                                <code>
    std::string green = "green"; // let's say we declare a variable called "green"
    enum TrafficLightColor &#123;
        green,  // will have redefinition error
        yellow, 
        red    
    };
                                </code>
                            </pre>
                        <li>Hence, C++ 11 introduces <strong>enum class</strong> concept. To make an enum class, simply add the <strong>class</strong> keyword after the enum keyword.</li>
                            <pre>
                                <code>
    enum class TrafficLightColor &#123;
        green,
        yellow, 
        red    
    };
                                </code>
                            </pre>
                        <li>Use case example of enum class</li>
                            <pre>
                                <code>
    #include &lt;iostream>
    #include &lt;string>
    
    enum class TrafficLightColor &#123;
        green,  // assigned 0
        yellow, // assigned 1
        red     // assigned 2
    };
    
    // instead of "int getTrafficLightStatus()"
    TrafficLightColor getTrafficLightStatus() &#123;
        return TrafficLightColor::green;
    }
    
    // instead of "void displayLight(int color)"
    void displayLight(TrafficLightColor color) &#123;
        if (color == TrafficLightColor::green) &#123;
            std::cout &lt;&lt; "green" &lt;&lt; '\n';
        }
        else if (color == TrafficLightColor::yellow) &#123;
            std::cout &lt;&lt; "yellow" &lt;&lt; '\n';
        }
        else if (color == TrafficLightColor::red) &#123;
            std::cout &lt;&lt; "red" &lt;&lt; '\n';
        }
    }

    int main() &#123;
        displayLight(getTrafficLightStatus());                       // output: "green"
        TrafficLightColor nextColor&#123; TrafficLightColor::yellow };    // variable declaration example
        std::cout &lt;&lt; static_cast&lt;int>(nextColor) &lt;&lt; '\n';            // output : 1
        displayLight(nextColor);                                     // output: "yellow"
        return 0;
    }
                                </code>
                            </pre>
                    </ul>
                <li>struct</li>
                    <ul>
                        <li>A <strong>struct</strong> allows us to group variables of mixed types together into a single unit.</li>
                        <li>The variables that are part of the struct are called <strong>members</strong>.</li>
                        <li>An example of struct:</li>
                            <pre>
                                <code>
    struct Employee &#123;
        int id&#123;};
        int age&#123;};
        bool isPermanent&#123;};
        double wage&#123;};
    };

    Employee john; 
    john.id = 1234;
    john.age = 32;
    john.wage = 24;
    john.isPermanent = false;
    Employee jack&#123; 1122, 20, 18, false };
                                </code>
                            </pre>
                        <li>We can set default value for the non-static struct members:</li>
                            <pre>
                                <code>
    struct Rectangle &#123;
        double length&#123; 1.0 };
        double width&#123; 1.0 };
    };
    Rectangle rectangleA&#123;}; // length = 1.0, width = 1.0
    Rectangle rectangleB&#123; 1.2 }; // length = 1.2, width = 1.0
                                </code>
                            </pre>
                        <li>We can also pass the entire struct as argument to a function.</li>
                            <pre>
                                <code>
    void printInformation(Employee employee) &#123;
        std::cout &lt;&lt; "ID:   " &lt;&lt; employee.id &lt;&lt; '\n';
        std::cout &lt;&lt; "Age:  " &lt;&lt; employee.age &lt;&lt; '\n';
        std::cout &lt;&lt; "Wage: " &lt;&lt; employee.wage &lt;&lt; '\n';
    }
                                </code>
                            </pre>
                        <li>A struct can be used as return type of function as well.</li>
                            <pre>
                                <code>
    struct Point3d &#123;
        double x&#123;};
        double y&#123;};
        double z&#123;};
    };

    Point3d getZeroPoint() &#123;
        // We can create a variable and return the variable.
        Point3d temp &#123; 0.0, 0.0, 0.0 };
        return temp;
    }
                                </code>
                            </pre>
                        <li>Nested structs are also possible.</li>
                            <pre>
                                <code>
    struct Employee &#123;
        int id&#123;};
        int age&#123;};
        double wage&#123;};
    };

    struct Company &#123;
        Employee CEO&#123;}; // Employee is a struct within the Company struct
        int numberOfEmployees&#123;};
    };

    Company companyA&#123;&#123;0001, 52, 999}, 1000};
    std::cout &lt;&lt; companyA.CEO.wage &lt;&lt; '\n';
                                </code>
                            </pre>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter10">
            <h2>Chapter 10: Arrays, Strings, Pointers, and References</h2>
            <ul>
                <li>Arrays</li>
                    <ul>
                        <li>Assuming you already have the basic understanding of arrays, so they are not covered here.</li>
                        <li>Arrays can be made from structs.</li>
                            <pre>
                                <code>
    struct Rectangle &#123;
        int length&#123;};
        int width&#123;};
    };
    Rectangle rects[5]&#123;}; // declare an array of 5 Rectangle
    std::cout &lt;&lt; rects[0].length &lt;&lt; '\n';
                                </code>
                            </pre>
                        <li>When declaring a fixed array, the length of the array must be a compile-time constant. For "array" with dynamic size, 
                            refer to C++ <a href="https://www.cplusplus.com/reference/vector/vector/" target="_blank" rel="noopener noreferrer">vector</a>.</li>
                        <li>To initlize the elements of a fixed array, we can use initializer list. 
                            If there are less initializers than the size of array, the rest of of the elements are initialized to zero.
                            If you didnt declare the length of an array, the compiler will set the length of array based on length of initializer list. 
                        </li>
                            <pre>
                                <code>
    int prime[5]&#123; 2, 3, 5, 7, 11 }; // use initializer list to initialize the fixed array
    int arrayA[10]&#123; 1, 2, 3}; // the rest of the elments are initilized to zero
    int arrayB[]&#123;0, 1, 2, 3, 4, 5} // let the initializer list set length of the array
                                </code>
                            </pre>
                        <li>Use a enum inside of a namespace, and then use it to map the elements of array.</li>
                            <pre>
                                <code>
    namespace StudentNames &#123;
        enum StudentNames &#123;
            kenny, // 0
            kyle, // 1
            stan, // 2
            butters, // 3
            cartman, // 4
            wendy, // 5
        };
    }

    int main() &#123;
        int testScores[5]&#123;}; 
        testScores[StudentNames::stan] = 76;
        return 0;
    }
                                </code>
                            </pre>
                        <li>Passing arrays to functions</li>
                            <ul>
                                <li>When a normal variable is passed by value, C++ copies the value of the argument into the function parameter.
                                    Hence, modifying the value of the parameter will not affect the original argument.</li>
                                <li>HOWEVER, <strong>when an array is passed into a function, the actual array is passed.</strong>.
                                    Hence, modifying the elements of array inside the function will also affect the original argument which is
                                    out of the function.</li>
                            </ul>
                        <li>To swap values of two variables, we can use the std::swap() function from C++ standard library. 
                            This function can be used for swapping elements of array as well.</li>
                        <li>To sort elements of array, we can use some algorithms such as bubble sort, selection sort and insertion sort.
                            But C++ standard library has a sorting function named std::sort() as well.</li>
                            <pre>
                                <code>
    #include &lt;iostream>
    #include &lt;iterator> // for std::size
    #include &lt;algorithm> // for std::sort
    
    int main()
    &#123;
        int array[]&#123; 10, 1, 22, 31, 5, 8, 3, 21 };
        std::sort(std::begin(array), std::end(array));
        for (int i = 0; i &lt; std::size(array); i++) &#123;
            std::cout &lt;&lt; array[i] &lt;&lt; '\n';
        }
        return 0;
    }
                                </code>
                            </pre>
                    </ul>
                <li>C-style Strings</li>
                    <ul>
                        <li>Other than std::string, C++ does support C-style Strings. And actually std::string is implemented using C-style strings</li>
                        <li>C-style string is an array of characters that uses a null terminator.</li>
                        <li><strong>Best practice: </strong>Use std::string instead of C-style strings.</li>
                        <li>Since C-style Strings are not preferred, they are not covered here.</li>
                    </ul>
                <li>Pointers</li>
                    <ul>
                        <li>The <strong>address-of operator (&)</strong> allows us to see what memory address is assigned to a variable.</li>
                        <li>The <strong>indirection operator (*)</strong> (also called <strong>dereference operator</strong>) allows us to access the value at a particular address:</li>
                        <li>A <strong>pointer</strong> is a variable that holds a memory address as its value.</li>
                        <pre>
                            <code>
    int x&#123; 5 };
    int* ptrX&#123;&x}; // initialize ptrX with address of vqriable x
    std::cout &lt;&lt; x &lt;&lt; '\n'; // print the value of variable x
    std::cout &lt;&lt; &x &lt;&lt; '\n'; // print the memory address of variable x
    std::cout &lt;&lt; ptrX &lt;&lt; '\n'; // print the address that ptrX is holding
    std::cout &lt;&lt; *(&x) &lt;&lt; '\n'; /// print the value at the memory address of variable x (parenthesis is optional)                            
                            </code>
                        </pre>
                        <li>Pointers are useful in many cases, but they will be covered in future chapters.</li>
                    </ul>
                <li>Null pointer</li>
                    <ul>
                        <li>A pointer holding a null value is called a <strong>null pointer</strong>.</li>
                        <li>In C++ 11, we can assign a pointer a null value by using the <strong>nullptr</strong> keyword:</li>
                            <ul>
                                <li>Example: float* ptr &#123; nullptr };  // ptr is now a null pointer</li>
                            </ul>
                        <li><strong>Best practice: </strong>Use nullptr to initialize your pointers to a null value if you’re not giving them another value.</li>
                        <li>C++ 11 also introduces a new type called std::nullptr_t (in header &lt;cstddef>), and it can only hold one value: nullptr.</li>
                    </ul>
                <li>Pointers and arrays</li>
                    <ul>
                        <li>In C++, when a fixed array is used in an expression, the fixed array will decay (be implicitly converted) into a pointer that points to the first element of the array.</li>
                            <pre>
                                <code>
    int array[5]&#123; 9, 7, 5, 3, 1 };

    // print address of the array's first element
    std::cout &lt;&lt; "Element 0 has address: " &lt;&lt; &array[0] &lt;&lt; '\n'; // example output: 0000008D7995FC54

    // print the value of the pointer the array decays to
    std::cout &lt;&lt; "The array decays to a pointer holding address: " &lt;&lt; array &lt;&lt; '\n'; // example output: 0000008D7995FC54
                                </code>
                            </pre>
                        <li>Hence, the following 2 function declarations are identical:</li>
                            <pre>
                                <code>
    void printSize(int array[]);
    void printSize(int* array); // this is lightly recommended as it makes clear that the parameter is being treated as a pointer
                                </code>
                            </pre>
                        <li>A side note is arrays in structs and classes don’t decay. This yields a useful way to prevent decay if desired, and will be valuable later when we write classes that utilize arrays.</li>
                    </ul>
                <li>Pointer arithmetic and array indexing</li>
                    <ul>
                        <li>If we have a pointer called 'ptr', then ptr + 1 then will return the memory address of the next object of the type that ptr points to.</li>
                            <pre>
                                <code>
    short value&#123; 7 }; // short is 2 bytes
    short* ptr&#123; &value };
    std::cout &lt;&lt; ptr &lt;&lt; '\n'; // If this points to 00000039785AF98A
    std::cout &lt;&lt; ptr+1 &lt;&lt; '\n'; // then this one will point to 2 bytes after ptr, which is 00000039785AF98C
                                </code>
                            </pre>
                        <li>Arrays are laid out sequentially in memory, and that is why we can use iterator to traverse through an array easily.</li>
                        <li>array[n] is equivalent to *(array + n), where n is an integer. The (array + n) points to the nth element of an array,
                            and hence deferencing it with * will get the value of nth element in that array.</li>
                        <li>Side Note: the algorithms library offers std::count_if, which counts elements that fulfill a condition.
                            We can also make use of std::begin to point to the first element of array, and then use std::end to point to the object AFTER the last element.</li>
                            <pre>
                                <code>
    #include &lt;iostream>
    #include &lt;algorithm> // for std::count_if
    #include &lt;iterator> // for std::begin and std::end
    
    bool isO(char ch) &#123;
        switch (ch) &#123;
            case 'O':
            case 'o':
                return true;
            default:
                return false;
        }
    }
    char sampleText[]&#123; "hello world" }; // using std::string sampleText&#123; "hello world" } is also the same
    auto numOfO&#123; std::count_if(std::begin(sampleText), std::end(sampleText), isO) };
    std::cout &lt;&lt; numOfO &lt;&lt; '\n';
                                </code>
                            </pre>
                    </ul>
                <li>C-style string symbolic constant is not covered here.</li>
                <li>Dynamic memory allocation with new and delete</li>
                    <ul>
                        <li>C++ supports 3 basic types of memory allocation</li>
                            <ul>
                                <li><strong>Static memory allocation</strong> happens for static and global variables.
                                    Memory for these types of variables is allocated once when your program is run and persists throughout the life of your program.</li>
                                <li><strong>Automatic memory allocation</strong> happens for function parameters and local variables.
                                    Memory for these types of variables is allocated when the relevant block is entered, and freed when the block is exited, as many times as necessary.</li>
                                <li><strong>Dynamic memory allocation</strong> is a way for running programs to request memory from the operating system when needed. 
                                    This memory does not come from the program’s limited stack memory -- instead, it is allocated from a much larger pool of memory managed by the operating system called the <strong>heap</strong>. 
                                    On modern machines, the heap can be gigabytes in size.</li>
                            </ul>
                        <li>Both static and automatic allocation have two things in common:</li>
                            <ul>
                                <li>The size of the variable / array must be known at compile time.</li>
                                <li>Memory allocation and deallocation happens automatically (when the variable is instantiated / destroyed).</li>
                            </ul>
                        <li>Dynamically allocating single variables</li>
                            <ul>
                                <li>To allocate a single variable dynamically, we use the scalar (non-array) form of the new operator. The new operator creates the object using that memory, and then returns a pointer containing the address of the memory that has been allocated.</li>
                                    <pre>
                                        <code>
    int* ptr&#123; new int }; // dynamically allocate an integer and assign the address to ptr so we can access it later
    *ptr = 7; // assign value of 7 to allocated memory

    int* ptr2&#123; new int &#123; 6 } }; // use uniform initialization
                                        </code>
                                    </pre>
                            </ul>
                        <li>When you dynamically allocate memory,</li>
                            <ul>
                                <li>You’re asking the operating system to reserve some memory for your program’s use.</li>
                                <li>If it can fulfill this request, it will return the address of that memory to your application.</li>
                                <li>From that point forward, your application can use this memory as it wishes. </li>
                                <li>When your application is done with the memory, it can return the memory back to the operating system to be given to another program.</li>
                            </ul>
                        <li>You may free a memory for reuse by using the <strong>delete</strong> operator.
                             Note that the delete operator doesn't actually delete anything, it simply returns the memory being pointed to back to the operating system.
                            However, after freeing the memory, remember to set the pointer to nullptr.</li>
                            <pre>
                                <code>
    // assume ptr has previously been allocated with operator new
    delete ptr; // return the memory pointed to by ptr to the operating system
    ptr = nullptr; // set ptr to be a null pointer
                                </code>
                            </pre>
                        <li>Memory leaks</li>
                            <ul>
                                <li>Dynamically allocated memory stays allocated until it is explicitly deallocated or until the program ends.</li>
                                <li>However, the pointers used to hold dynamically allocated memory addresses follow the normal scoping rules for local variables.</li>
                                <li>Consider the following:</li>
                                    <pre>
                                        <code>
    void doSomething() &#123;
        int* ptr&#123; new int&#123;} };
    }
                                        </code>
                                    </pre>
                                <li>Because pointers variables are just normal variables, when the function ends, ptr will go out of scope.</li>
                                <li>Then, ptr is destroyed there are no more references to the dynamically allocated memory.</li>
                                <li>Now, the memory address is allocated but now we dont have any reference to that memory address, and hence we can't free the memory address.</li>
                                <li>This is called a <strong>memory leak</strong>, which means your program loses the address of some bit of dynamically allocated memory before giving it back to the operating system. </li>
                                <li>Memory leaks will eat up your free memory while the program is running.</li>
                                <li>The following 2 cases will also result in memory leaks:</li>
                                    <pre>
                                        <code>
    // CASE 1 - a pointer is assigned another value
    int value = 5;
    int* ptr&#123; new int&#123;} }; // allocate memory
    ptr = &amp;value; // old address lost, memory leak results

    // CASE 2 - double-allocation
    int* ptr&#123; new int&#123;} };
    ptr = new int&#123;}; // old address lost, memory leak results
                                        </code>
                                    </pre>
                                <li>The solution for memory leaks would be deleting or freeing the pointer before it is out of scope or before assigning new value to it.</li>
                            </ul>
                    </ul>
                <li>Pointers and const</li>
                    <ul>
                        <li>A non-const pointer can be redirected to point to other addresses.</li>
                        <li>A const pointer always points to the same address, and this address can not be changed.</li>
                        <li>A pointer to a non-const value can change the value it is pointing to. These can not point to a const value.</li>
                        <li>A pointer to a const value treats the value as const (even if it is not), and thus can not change the value it is pointing to.</li>
                        <pre>
                            <code>
    int value&#123; 5 };
    const int* ptr1&#123; &value }; // ptr1 points to a "const int", so this is a pointer to a const value.
    int* const ptr2&#123; &value }; // ptr2 points to an "int", so this is a const pointer to a non-const value.
    const int* const ptr3&#123; &value }; // ptr3 points to a "const int", so this is a const pointer to a const value.
                            </code>
                        </pre>
                    </ul>
                <li>Reference variables</li>
                    <ul>
                        <li>Other than normal variables and pointers, C++ also supports another type of variables - references.</li>
                        <li>A <strong>reference</strong> is a C++ variable that acts as an alias to another object or value, 
                            and it acts identically to the value it is referencing.</li>
                            <pre>
                                <code>
    int value&#123; 5 }; // normal integer
    int& y&#123; x }; // y is a reference to variable x
    int& z&#123; y }; // z is also a reference to variable x
                                </code>
                            </pre>
                        <li>In the above snippet, setting or getting the value of x, y, or z will all do the same thing (set or get the value of x).
                            The address of the references also same with the variable that they are referencing.
                        </li>
                            <pre>
                                <code>
    int x&#123; 5 }; // normal integer
    int& y&#123; x }; // y is a reference to variable m
    int& z&#123; y }; // z is also a reference to variable m
    std::cout &lt;&lt; x &lt;&lt; '\n'; // output: 5
    std::cout &lt;&lt; y &lt;&lt; '\n'; // output: 5
    std::cout &lt;&lt; z &lt;&lt; '\n'; // output: 5
    x = 6;
    std::cout &lt;&lt; x &lt;&lt; '\n'; // output: 6
    std::cout &lt;&lt; y &lt;&lt; '\n'; // output: 6
    std::cout &lt;&lt; z &lt;&lt; '\n'; // output: 6
    ++z;
    std::cout &lt;&lt; x &lt;&lt; '\n'; // output: 7
    std::cout &lt;&lt; y &lt;&lt; '\n'; // output: 7
    std::cout &lt;&lt; z &lt;&lt; '\n'; // output: 7

    std::cout &lt;&lt; &x &lt;&lt; '\n'; // output: 000000614ABDF5A4
    std::cout &lt;&lt; &y &lt;&lt; '\n'; // output: 000000614ABDF5A4
    std::cout &lt;&lt; &z &lt;&lt; '\n'; // output: 000000614ABDF5A4
                                </code>
                            </pre>
                        <li>Referencces must be initialized to a variable value, there is NO such thing as a null reference.</li>
                        <li>Once initialized, a reference can not be changed to reference another variable. </li>
                        <li>References are most often used as function parameters.</li>
                            <ul>
                                <li>In this context, the reference parameter acts as an alias for the argument, and no copy of the argument is made into the parameter.</li>
                                <li>This can lead to better performance if the argument is large or expensive to copy.</li>
                                <li>Example:</li>
                                    <pre>
                                        <code>
    // ref is a reference to the argument passed in, not a copy
    void setNumTo6(int& ref) &#123;
        ref = 6;
    }

    int main () &#123;
        int num&#123; 5 };
        setNumTo6(num);
        std::cout &lt;&lt; num &lt;&lt; '\n'; // output: 6
        return 0;
    }               
                                        </code>
                                    </pre>
                            </ul>
                        <li><strong>Best practice: </strong>Pass arguments by non-const reference (rather than by pointer) when the argument needs to be modified by the function, 
                        applicable for variables that are not pointers or non-fundamental data types (such as structs). Fundametal data types such as int, double etc should be passed by value.</li>
                        <li>References vs pointers</li>
                            <ul>
                                <li>References and pointers have an interesting relationship -- a reference acts like a pointer that implicitly performs indirection through it when accessed</li>
                                <li>Hence *ptr and ref are identical.</li>
                                <pre>
                                    <code>
    int valueB&#123; 5 };
    int* const ptrC&#123; &valueB };
    int& refD&#123; valueB };
    std::cout &lt;&lt; *ptrC &lt;&lt; '\n'; // output: 5
    std::cout &lt;&lt; refD &lt;&lt; '\n'; // output: 5
    *ptrC = 6;
    std::cout &lt;&lt; *ptrC &lt;&lt; '\n'; // output: 6
    std::cout &lt;&lt; refD &lt;&lt; '\n';  // output: 6
    refD = 7;
    std::cout &lt;&lt; *ptrC &lt;&lt; '\n'; // output: 7
    std::cout &lt;&lt; refD &lt;&lt; '\n';  // output: 7
                                    </code>
                                </pre>
                            </ul>
                        <li>References and const</li>
                            <ul>
                                <li>Much like a pointer to a const value, a reference to a const value can reference a non-const variable. When accessed through a reference to a const value, 
                                    the value is considered const even if the original variable is not:</li>
                                    <pre>
                                        <code>
    int apple&#123; 5 };
    const int& refApple&#123; apple }; // apple is not const, but refApple is still "a reference to const value"
    apple = 6;
    std::cout &lt;&lt; apple &lt;&lt; '\n'; //ouput: 6
    std::cout &lt;&lt; refApple &lt;&lt; '\n'; // output: 6
    // refApple = 7; // illegal -- refApple is const
    const int orange&#123; 3 };
    const int& refOrange&#123; orange }; // refOrange is also "a reference to const value"
    const int& refGrapes&#123; 8 }; //refGrapse is also "a reference to const value"                                        
                                        </code>
                                    </pre>
                                <li></li>
                            </ul>
                        <li>References used as function parameters can also be const.</li>
                            <ul>
                                <li>This allows us to access the argument without making a copy of it, while guaranteeing that the function will not change the value being referenced.</li>
                                <pre>
                                    <code>
    void printIt(const int& ref) &#123; // to guarantee the function will not change the value being referenced
        // ref = 6; // illegal -- ref is const
        std::cout &lt;&lt; ref;
    }
                                    </code>
                                </pre>
                            </ul>
                    </ul>
                <li>for-each loops</li>
                    <ul>
                        <li>The following is an example of for-each loop statement:</li>
                            <pre>
                                <code>
    constexpr int fibonacci[]&#123; 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 };
    for (int number : fibonacci) // iterate over array fibonacci
    &#123;
       std::cout &lt;&lt; number &lt;&lt; ' ';
    }
                                </code>
                            </pre>
                        <li>Since elements of the array should have the same type, it is suitable to use auto keyword to let compiler deduce the type.</li>
                        <li>Moreover, we can make use of reference to avoid copying array elements.</li>
                        <li>And if we are not going to modify the array elements, it's a good idea to make the reference const.</li>
                        <pre>
                            <code>
    std::string array[]&#123; "peter", "likes", "frozen", "yogurt" };
    for (const auto& element: array) // element is a const reference to the currently iterated array element
    &#123;
        std::cout &lt;&lt; element &lt;&lt; ' ';
    }
                            </code>
                        </pre>
                    </ul>
                <li>void pointer</li>
                    <ul>
                        <li>There is such thing called void pointer, but you ocassionally will use them. So this is not covered here.</li>
                    </ul>
                <li>pointers to pointers</li>
                    <ul>
                        <li>A pointer can point to a pointer and it works just like a normal pointer.</li>
                        <li>It is recommended to avoid using pointers to pointers unless no other options are available,
                             because they're complicated to use and potentially dangerous. Hence, it is not covered here also.</li>
                    </ul>
                <li>std::array</li>
                    <ul>
                        <li>Unlike fixed arrays which decay into pointers, std::array provides fixed array functionality that won’t decay when passed into a function.</li>
                        <li>std::array is defined in the &lt;array> header, inside the std namespace.</li>
                            <pre>
                                <code>
    #include &lt;array>
    std::array&lt;int, 3> myArray; // declare an integer array with length 3
                                </code>
                            </pre>
                        <li>Take note that the length of array must be known during compile-time, means we can not pass a variable for the length, unless it is a const variable</li>
                            <pre>
                                <code>
    int n = 5;
    const int x&#123; 6 };
    // std::array&lt;int, n> testA&#123; 1, 2, 3 }; // will have error
    std::array&lt;int, x> testB&#123; 1, 2, 3 }; // same as std::array&lt;int, 6> since x is const
    for (const auto num : testB) &#123;
        std::cout &lt;&lt; num &lt;&lt; ' '; // output: 1 2 3 0 0
    }
                                </code>
                            </pre>
                        <li>size() function can be used to retrieve length</li>
                        <table>
                            <tr class="trFlex">
                                <th class="thHalf">built-in fixed array</th>
                                <th class="thHalf">std::array</th>
                            </tr>
                            <tr class="trFlex">
                                <td class="tdHalf">int myArray1[5] &#123; 9, 7, 5, 3, 1 };</td>
                                <td class="tdHalf">std::array&lt;int, 5> myArray2 &#123; 9, 7, 5, 3, 1 };</td>
                            </tr>
                            <tr class="trFlex">
                                <td class="tdHalf">decay into pointers</td>
                                <td class="tdHalf">DOES NOT decay into pointers</td>
                            </tr>
                            <tr class="trFlex">
                                <td class="tdHalf">can omit array length when providing an initializer</td>
                                <td class="tdHalf">CANNOT omit array length when providing an initializer</td>
                            </tr>
                            <tr class="trFlex">
                                <td class="tdHalf">decay into pointers</td>
                                <td class="tdHalf">do not decay into pointers</td>
                            </tr>
                            <tr class="trFlex">
                                <td class="tdHalf">use .length to get length of array</td>
                                <td class="tdHalf">use .size() to get length of array</td>
                            </tr>
                            <tr class="trFlex">
                                <td class="tdHalf">does not have .begin() and .end() function<br>std::sort(std::begin(array), std::end(array));</td>
                                <td class="tdHalf">has .begin() and .end() function<br>std::sort(myArray.begin(), myArray.end());</td>
                            </tr>
                        </table>
                        <li>Passing std::array of different lengths to a function</li>
                            <ul>
                                <li>When we use a std::array as a function parameter, we have to specify the element type and array length,
                                     because they are part of the std::array element</li>
                                    <pre>
                                        <code>
    void printArray(const std::array&lt;int, 5>& myArray) &#123;
        for (auto element : myArray)
            std::cout &lt;&lt; element &lt;&lt; ' ';
        std::cout &lt;&lt; '\n';
    }
                                        </code>
                                    </pre>
                                <li>The downside of this is our function can only handle arrays of specific type and length.s</li>
                                <li>The solution of this problem is by making use of C++ function templates:</li>
                                    <pre>
                                        <code>
    #include &lt;array>
    #include &lt;cstddef>
    #include &lt;iostream>
    
    // printArray is a template function
    template &lt;typename T, std::size_t size> // parameterize the element type and size
    void printArray(const std::array&lt;T, size>& myArray) &#123;
        for (auto element : myArray)
            std::cout &lt;&lt; element &lt;&lt; ' ';
        std::cout &lt;&lt; '\n';
    }
    
    int main() &#123;
        std::array myArray5&#123; 9.0, 7.2, 5.4, 3.6, 1.8 };
        printArray(myArray5);
    
        std::array myArray7&#123; 9.0, 7.2, 5.4, 3.6, 1.8, 1.2, 0.7 };
        printArray(myArray7);
    
        return 0;
    }
                                        </code>
                                    </pre>
                                <li>Another downside of std::array is, the size() function and array index parameter to operator[] use a type called <span class="highlightInGrey">size_type</span>, 
                                    which is defined by the C++ standard as an <span style="font-style:italic;">unsigned</span> integral type. 
                                    Hence, the following code snippet will cause a deadloop since we used the <span class="highlightInGrey">auto</span> keyword to declare the variable i,
                                    and unsigned integer will wrap around when it reachs its limit. </li>
                                    <pre>
                                        <code>
    std::array&lt;int,5> myArrayABC &#123; 7, 3, 1, 9, 5 };
    std::cout &lt;&lt; typeid(myArrayABC.size()).name() &lt;&lt; '\n'; // output: unsigned __int64

    // this for-loop can work, but actually there is a hidden signed/unsigned mismatch in this code
    for (int i&#123; 0 }; i &lt; myArrayABC.size(); ++i) &#123;
        std::cout &lt;&lt; myArrayABC[i] &lt;&lt; ' ';
    }
                                        </code>
                                    </pre>
                                <li>You must be aware that the .size() function returns a <span class="highlightInGrey">size_t</span> type which is unsigned integral type,
                                     and the following example will have error because the iterator can never be less than zero.</li>
                                    <pre>
                                        <code>
    // this will have error
    for (auto i&#123; myArrayABC.size() - 1}; i >= 0; --i) &#123;
        std::cout &lt;&lt; myArrayABC[i] &lt;&lt; ' ';
    }
                                        </code>
                                    </pre>

                                <li>To avoid signed/unsigned missmatch problem, we can use the std::size_t type to declare the index variable:</li>
                                    <pre>
                                        <code>
    #include &lt;cstddef> // std::size_t
    for (std::size_t i&#123; 0 }; i &lt; myArrayABC.size(); ++i) &#123;
        std::cout &lt;&lt; myArrayABC[i] &lt;&lt; ' ';
        std::cout &lt;&lt; typeid(i).name() &lt;&lt; '\n'; // output: unsigned __int64
    }
                                        </code>
                                    </pre>
                                <li>A better solution is avoid manual indexing of std::array, use range-based for-loops if possible.</li>
                                    <pre>
                                        <code>
    // using range-based for-loop
    for (auto num : myArrayABC) &#123;
        std::cout &lt;*&lt; num &lt;*&lt; '\n';
    }
                                        </code>
                                    </pre>
                            </ul>
                        <li>std::array supports a second form of array element access (the at() function) that does bounds checking, and hence will be slower than operator[]</li>
                            <pre>
                                <code>
    std::array myArray &#123; 9, 7, 5, 3, 1 };
    myArray.at(1) = 6; // array element 1 is valid, sets array element 1 to value 6
    myArray.at(9) = 10; // array element 9 is invalid, will throw a runtime error
                                </code>
                            </pre>
                    </ul>
                <li>std::vector</li>
                    <ul>
                        <li>The C++ standard library provides std::vector (lives in the &lt;vector> header) that makes working with dynamic arrays safer and easier.</li>
                        <li>std::vector provides dynamic array functionality that handles its own memory management.</li>
                        <li>This means you can create arrays that have their length set at run-time,
                             without having to explicitly allocate and deallocate memory using <span class="highlightInGrey">new</span> and <span class="highlightInGrey">delete</span>.
                             This is because std::vector will dynamically allocate memory for its contents as requested.</li>
                            <pre>
                                <code>
    std::vector&lt;int> arrayC; // no need to specify length at the declaration
    std::vector&lt;int> arrayD(5); // using direct initialization, we can create a vector with specific number of elements,
    std::vector&lt;int> arrayE = &#123; 9, 7, 5, 3, 1 }; // use initializer list to initialize array (Before C++11)
    std::vector&lt;int> arrayF&#123; 9, 7, 5, 3, 1 }; // use uniform initialization to initialize array
    int n = 5;
    std::vector&lt;int> testV(n, -1); // direct initialization with run-time length, and initialize all the elements to -1
    for (const auto num : testV) &#123;
        std::cout &lt;&lt; num &lt;&lt; ' '; // output: -1 -1 -1 -1 -1
    }
                                </code>
                            </pre>
                        <li>std::vector supports both <span class="highlightInGrey">[]</span> and <span class="highlightInGrey">at()</span> function</li>
                        <li>As of C++11, you can also assign values to a std::vector using an initializer-list, and then the vector will self-resize to match the number of elements provided.</li>
                            <pre>
                                <code>
    array = &#123; 0, 1, 2, 3, 4 }; // okay, array length is now 5
    array = &#123; 9, 8, 7 }; // okay, array length is now 3
                                </code>
                            </pre>
                        <li>The memory of std::vector variables will be deallocated as soon as the varibale goes out of scope. 
                            This helps prevent memory leaks, and make std::vector much safer to use.</li>
                        <li>To get the length of a vector, use .size() function</li>
                        <li>The .size() of std::vector is similar to .size() of std::array, which returns a nested type of <span class="highlightInGrey">size_type</span></li>
                        <li>A vector can be resized using the <span class="highlightInGrey">resize()</span> function</li>
                            <pre>
                                <code>
    std::vector&lt;int> arrayF&#123; 4, 5, 3, 6, 8 };
    arrayF.resize(3);
    for (auto i : arrayF)
        std::cout &lt;&lt; i &lt;&lt; ' '; // output: 4 5 3
    std::cout &lt;&lt; '\n';
    arrayF.resize(6);
    for (auto i : arrayF)
        std::cout &lt;&lt; i &lt;&lt; ' '; // output: 4 5 3 0 0 0
                                </code>
                            </pre>
                    </ul>
                <li>Iterators</li>
                    <ul>
                        <li>An iterator is an object designed to traverse through a container (e.g. the values in an array, or the characters in a string), providing access to each element along the way.</li>
                        <li>Pointers as an iterator</li>
                            <ul>
                                <li>The simplest kind of iterator is a pointer.</li>
                                    <pre>
                                        <code>
    #include &lt;array>
    #include &lt;iostream>
    
    int main() &#123;
        std::array &lt;int,7> data&#123; 0, 1, 2, 3, 4, 5, 6 };
    
        auto begin&#123; &data[0] };
        // note that this points to one spot beyond the last element
        auto end&#123; begin + std::size(data) };
    
        // for-loop with pointer
        for (auto ptr&#123; begin }; ptr != end; ++ptr) // ++ to move to next element
        &#123;
            std::cout &lt;&lt; *ptr &lt;&lt; ' '; // Indirection to get value of current element
        }
        std::cout &lt;&lt; '\n';
        return 0;
    }
                                        </code>
                                    </pre>
                            </ul>
                        <li>Standard library iterators</li>
                            <ul>
                                <li>Instead of manually calculating our own begin and end points (like what is done in previous code snippet), 
                                    we can use the .begin() and .end() functions provided by most of the standard library containers.
                                </li>
                                    <pre>
                                        <code>
    std::array &lt;int,3> array2&#123; 1, 2, 3 };

    for (auto p&#123; array2.begin() }; p != array2.end(); ++p) // ++ to move to next element.
    &#123;
        std::cout &lt;&lt; *p &lt;&lt; ' '; // Indirection to get value of current element.
    }
    std::cout &lt;&lt; '\n';

    return 0;
                                        </code>
                                    </pre>
                            </ul>
                        <li>All types that have <span class="highlightInGrey">begin</span> and <span class="highlightInGrey">end</span> member functions 
                            or can be used with <span class="highlightInGrey">std::begin</span> and <span class="highlightInGrey">std::end</span> are usable in range-based for-loops.</li>
                        <li>Iterator invalidation</li>
                            <ul>
                                <li>Some operations that modify containers (such as adding an element to a <span class="highlightInGrey">std::vector</span>) can have the side effect of 
                                    causing the elements in the container to change addresses.</li>
                                <li>When this happens, the iterator initialized previously might no longer be valid.</li>
                                <li>Please beware that accessing an invalidated iterator produces undefined behavior.</li>
                            </ul>

                    </ul>
                <li>Standard Library Algorithms</li>
                    <ul>
                        <li>The algorithms library has 3 categories of functionality</li>
                            <ul>
                                <li><strong>Inspectors</strong> -- Used to view (but not modify) data in a container. Examples include searching and counting.</li>
                                <li><strong>Mutators</strong> -- Used to modify data in a container. Examples include sorting and shuffling.</li>
                                <li><strong>Facilitators</strong> -- Used to generate a result based on values of the data members. Examples include objects that multiply values, or objects that determine what order pairs of elements should be sorted in.</li>
                            </ul>
                        <li>Here are some examples of functions</li>
                            <ul>
                                <li>std::find</li>
                                <li>std::find_if</li>
                                <li>std::count</li>
                                <li>std::count_if</li>
                                <li>std::sort</li>
                                <li></li>
                                <li>std::for_each</li>
                            </ul>
                        <li>For examples and references, refer to the <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-standard-library-algorithms/" target="_blank" rel="noopener noreferrer">tutorial</a>.</li>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter11">
            <h2>Chapter 11: Functions</h2>
            <ul>
                <li>Passing arguments by value</li>
                    <ul>
                        <li>When an argument is passed by value, the argument’s value is copied into the value of the corresponding function parameter.</li>
                        <li>When to use pass by value:</li>
                            <ul>
                                <li>When passing fundamental data types and enumerators, and the function does not need to change the argument.</li>
                            </ul>
                        <li>When not to use pass by value:</li>
                            <ul>
                                <li>When passing structs or classes (including std::array, std::vector, and std::string).</li>
                            </ul>
                    </ul>
                <li>Passing arguments by reference</li>
                    <ul>
                        <li>When an argument is passed by reference, a reference is created to the actual argument (which takes minimal time) and no copying of values takes place. 
                            This allows us to pass large structs and classes with a minimum performance penalty.</li>
                        <li>Take note that: Non-const references cannot bind to r-values. A function with a non-const reference parameter cannot be called with literals or temporaries.</li>
                            <pre>
                                <code>
    #include &lt;string>

    void foo(std::string& text) &#123;}
    
    int main() &#123;
        std::string text&#123; "hello" };
    
        foo(text); // ok
        foo(text + " world"); // illegal, non-const references can't bind to r-values.
    
        return 0;
                                        }
                                </code>
                            </pre>
                        <li>When to use pass by reference:</li>
                            <ul>
                                <li>When passing structs or classes (use const if read-only).</li>
                                <li>When you need the function to modify an argument.</li>
                                <li>When you need access to the type information of a fixed array.</li>
                            </ul>
                        <li>When not to use pass by reference:</li>
                            <ul>
                                <li>When passing fundamental types that don’t need to be modified (use pass by value).</li>
                            </ul>
                    </ul>
                <li>Passing arguments by address</li>
                    <ul>
                        <li>Because the argument is an address, the function parameter must be a pointer.
                             The function can then dereference the pointer to access or change the value being pointed to.</li>
                        <li>Example:</li>
                            <pre>
                                <code>
    #include &lt;iostream>

    void foo(int* ptr) &#123;
        *ptr = 6;
    }
    
    int main() &#123;
        int value&#123; 5 };
    
        std::cout &lt;&lt; "value = " &lt;&lt; value &lt;&lt; '\n';
        foo(&value);
        std::cout &lt;&lt; "value = " &lt;&lt; value &lt;&lt; '\n';
        return 0;
    }
                                </code>
                            </pre>
                        <li>It is always a good idea to ensure parameters passed by address are not null pointers before dereferencing them, because it might cause the program to crash.</li>
                            <pre>
                                <code>
    void printArray(int* array, int length) &#123;
        // if user passed in a null pointer for array, bail out early!
        if (!array)
            return;

        for (int index&#123; 0 }; index &lt; length; ++index)
            std::cout &lt;&lt; array[index] &lt;&lt; ' ';
    }
                                </code>
                            </pre>
                        <li>When you pass a pointer to a function, the pointer’s value (the address it points to) is copied from the argument to the function’s parameter. 
                            Hence, you can simply set the ptr to null in the function and it won't affect the original pointer argument. 
                            However, if you deference the address and then change it's value, the value stored at the original value will be changed also.
                            Moreover, if you pass the address by reference, then the original pointer can be modified in the function.
                        </li>
                            <pre>
                                <code>
    #include &lt;iostream>
    void setToNull(int* tempPtr) &#123;
        // we're making tempPtr point at something else, not changing the value that tempPtr points to.
        tempPtr = nullptr; // use 0 instead if not C++11
    }
    void setToNullByReference(int*& tempPtr) &#123;
        // tempPtr is now a reference to a pointer, so any changes made to tempPtr will change the argument as well!
        tempPtr = nullptr; // use 0 instead if not C++11
    }
    void setToSix(int* tempPtr) &#123;
        *tempPtr = 6; // we're changing the value that tempPtr (and ptr) points to
    }

    int main() &#123;
        int five&#123; 5 };
        int* ptr&#123; &five };
        setToNull(ptr); // tempPtr will receive a copy of ptr
        std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // output: 5
        setToSix(ptr);
        std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // output: 6
        setToNullByReference(ptr);
        // ptr has now been changed to nullptr!
        if (ptr)
            std::cout &lt;&lt; *ptr;
        else
            std::cout &lt;&lt; "ptr is null"; // output: ptr is null 
        return 0;
    }
                                </code>
                            </pre>
                        <li>From the code snippet above, we can say that "pass by address" is actually just passing an address by value</li>
                        <li><strong>Best practice: </strong>Prefer pass by reference to pass by address whenever applicable.</li>
                    </ul>
                <li>Returning values by value, reference, and address</li>
                    <ul>
                        <li>Return by address was often used to return dynamically allocated memory to the caller:</li>
                            <pre>
                                <code>
    int* allocateArray(int size)
    &#123;
        return new int[size];
    }

                                </code>
                            </pre>
                        <li>Return by reference is typically used to return arguments passed by reference to the function back to the caller.</li>
                            <pre>
                                <code>
    // Returns a reference to the index element of array
    int& getElement(std::array&lt;int, 25>& array, int index)
    &#123;
        // we know that array[index] will not be destroyed when we return to the caller (since the caller passed in the array in the first place!)
        // so it's okay to return it by reference
        return array[index];
    }
                                </code>
                            </pre>
                        <li>Returning multiple values</li>
                            <ul>
                                <li>using a data-only struct:</li>
                                    <ul>
                                        <li>Example</li>
                                            <pre>
                                                <code>
    #include &lt;iostream>

    struct S
    &#123;
        int m_x;
        double m_y;
    };
    
    S returnStruct()
    &#123;
        S s;
        s.m_x = 5;
        s.m_y = 6.7;
        return s;
    }
    
    int main()
    &#123;
        S s&#123; returnStruct() };
        std::cout &lt;&lt; s.m_x &lt;&lt; ' ' &lt;&lt; s.m_y &lt;&lt; '\n';
    
        return 0;
    }
                                                </code>
                                            </pre>
                                    </ul>
                                <li>use std::tuple</li>
                                    <ul>
                                        <li>A tuple is a sequence of elements that may be different types, where the type of each element must be explicitly specified.</li>
                                        <li>Example:</li>
                                            <pre>
                                                <code>
    #include &lt;tuple>
    #include &lt;iostream>

    std::tuple&lt;int, double> returnTuple() // return a tuple that contains an int and a double
    &#123;
        return &#123; 5, 6.7 };
    }

    int main()
    &#123;
        std::tuple s&#123; returnTuple() }; // get our tuple
        std::cout &lt;&lt; std::get&lt;0>(s) &lt;&lt; ' ' &lt;&lt; std::get&lt;1>(s) &lt;&lt; '\n'; // use std::get&lt;n> to get the nth element of the tuple (counting from 0)

        return 0;
    }
                                                </code>
                                            </pre>
                                        <li>You can also use std::tie to unpack the tuple into predefined variables, like so:</li>
                                            <pre>
                                                <code>
    #include &lt;tuple>
    #include &lt;iostream>

    std::tuple&lt;int, double> returnTuple() // return a tuple that contains an int and a double
    &#123;
        return &#123; 5, 6.7 };
    }

    int main()
    &#123;
        int a;
        double b;
        std::tie(a, b) = returnTuple(); // put elements of tuple in variables a and b
        std::cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; '\n';

        return 0;
    }
                                                </code>
                                            </pre>
                                    </ul>
                            </ul>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div>
    </div>
    <div (click)="scrollTo('contentList')" class="floatingIconDiv">
        <fa-icon  [icon]="faArrowAltCircleUp" size="2x"></fa-icon>
    </div>
</div>