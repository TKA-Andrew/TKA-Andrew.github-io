<div class="flexContainer">
    <div id="contentList">
        <mat-accordion displayMode="flat" style="padding-left: 5px; padding-right: 5px;">
            <mat-expansion-panel style="margin-top: 5px;">
                <mat-expansion-panel-header>
                    <mat-panel-title>
                        C++
                    </mat-panel-title>
                </mat-expansion-panel-header>
                <button mat-button class="listItem" (click)="scrollTo('chapter1')">Chapter 1: C++ Basics</button>
                <button mat-button class="listItem" (click)="scrollTo('chapter2')">Chapter 2: Functions and Files</button>
                <button mat-button class="listItem" (click)="scrollTo('chapter3')">Chapter 3: Debugging C++ Programs</button>
                <button mat-button class="listItem" (click)="scrollTo('chapter4')">Chapter 4: Fundamental Data Types</button>
            </mat-expansion-panel>
        </mat-accordion>
    </div>
    <div fxLayout="column" fxLayout="column">
        <div>
            <h1>C++</h1>
            <h2>Introduction</h2>
            <p>The following are mainly the notes summarized from <a href="https://www.learncpp.com/" target="_blank" rel="noopener noreferrer">learncpp.com</a>.</p>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter1">
            <h2>Chapter 1: C++ Basics</h2>
            <ul>
                <li>Every C++ program must have a special function named main (all lower case letters).</li>
                <li>In C++, an <strong>object</strong> is a region of storage (usually memory) that has a value and other associated properties.</li>
                <li>A named object is called a <strong>variable</strong>, and the name of the object is called an <strong>identifier</strong></li>
                <li>In C++, the type of a variable must be known at compile-time (when the program is compiled), and that type can not be changed without recompiling the program.</li>
                <li>4 ways to initialize variables in C++</li>
                    <ul>
                        <li>int a; // Uninitalizaed (ERROR)</li>
                        <li>int b = 5; // Copy Initialization (NOT RECOMMENDED)</li>
                        <li>int c(6); // Direct Initialization (NOT RECOMMENDED)</li>
                        <li>int d&#123;7}; // List Initilization or Uniform Initilization (RECOMMENDED)</li>
                    </ul>
                <li>List initialization has the added benefit of disallowing “narrowing” conversions, whereas copy initialization and direct initialization only prompt warning.</li>
                <ul>
                    <li>int a = 3.5; // will have warning</li>
                    <li>int b(3.5); // will have warning</li>
                    <li>int c&#123;3.5}; // will have error</li>
                </ul>
                <li>Initializing variables with empty braces &#123;} will initialize the variable to either zero or empty</li>
                <li>Using '\n' is typically preferred as compared to std::endl because the later has an extra unnecessary action of flushing the output.</li>
                <li>Using this statement as example: int x&#123;2 + 3}</li>
                    <ul>
                        <li>'2' and '3' are <strong>literal</strong></li>
                        <li>'+' is <strong>operator</strong></li>
                        <li>'2 + 3' is <strong>expression</strong></li>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter2">
            <h2>Chapter 2: Functions and Files</h2>
            <ul>
                <li>Nested functions are not supported in C++</li>
                <li>Your main function should return 0 if the program ran normally.</li>
                <li>The C++ standard only defines the meaning of 3 status codes:
                    <ul>
                        <li>0 >> means the program executed successfully</li>
                        <li>EXIT_SUCCESS >> means the program executed successfully</li>
                        <li>EXIT_FAILURE >> means the program did not executed successfully</li>
                    </ul>
                </li>
                <li>Failure to return a value from a function with a non-void return type (other than main) will result in undefined behavior.</li>
                <li>A <strong>function parameter</strong> is a variable used in a function.</li>
                <li>An <strong>argument</strong> is a value that is passed from the caller to the function</li>
                <li>The C++ specification does not define whether function calls evaluate arguments left to right or right to left. 
                    Take care not to make function calls where argument order matters.</li>
                <li>Always do a <strong>forward declaration</strong> to tell the compiler about the existence of an identifier (including function) before actually defining the identifier.</li>
                <li>Example:</li>
                <pre>
                    <code>
    #include &lt;iostream>
    int getValueFromUser(); // forward declaration
    int multiplyBy2(int num); // forward declaration

    int main()
    &#123;
        int num&#123; getValueFromUser() }; // initialize num with the return value of getValueFromUser()
        std::cout &lt;&lt; num &lt;&lt; " doubled is: " &lt;&lt; multiplyBy2(num) &lt;&lt; '\n'; // num here is called argument
        return 0;
    }

    int getValueFromUser()
    &#123;
        std::cout &lt;&lt; "Enter an integer: ";
        int input&#123;};
        std::cin >> input;

        return input;
    }

    // num here is called parameter
    int multiplyBy2(int num) &#123;
        return num * 2;
    }
                    </code>
                </pre>
                <li>Declaration vs Definition</li>
                    <ul>
                        <li>A <strong>declaration</strong> is a statement that tells the compiler about the existence of an identifier
                            and its type information.</li>
                        <li>A <strong>definition</strong> actually implements (for functions or types) or instantiates (for variables) the identifier.</li>
                    </ul>
                <li>Namespace</li>
                    <ul>
                        <li>A <strong>namespace</strong> is a declarative region that provides a scope (called namespace scope) to the identifiers (the names of types, functions, variables, etc) inside it</li>
                        <li>In C++, any name that is not defined inside a class, function, or a namespace is considered to be part of <strong>global namespace</strong> (sometimes called <strong>global scope</strong>)</li>
                        <li>If there are identical names within an explicit namespace or global namespace, <strong>naming collision</strong> error will be produced.</li>
                        <li>A common namespace that we always use is <span style="font-style: italic;">std</span>, which we always use the :: symbol (scope resolution operator) to link 
                            std namespace and the identifiers within it.</li>
                            <ul>
                                <li>std::cout &lt;&lt; "Hello world!"; // example</li>
                            </ul>
                        <li>Another way to access identifiers inside a namespace is to use a <span style="font-style: italic;">using directive</span> statement (for example: <span style="font-style: italic;">using namespace std;</span>).
                        However, avoid using this as it violates the reason why namespaces were added in the first place.</li>
                    </ul>
                <li>Translation & Preprocessor</li>
                    <ul>
                        <li>Prior to compilation, the code file goes through a phase known as <strong>translation</strong>.</li>
                        <li>The translation phases involves the <strong>preprocessor</strong>, which can be best thought of as a separate program that manipulates the text in each code file.</li>
                        <li><strong>Preprocessor directives</strong> are instructions that start with a # symbol and end with a newline (NOT a semicolon).</li>
                        <li>Directives are resolved before compilation, from top to bottom on a file-by-file basis, therefore the output of the preprocessor contains no directives at all.</li>
                        <li>#include</li>
                            <ul>
                                <li>When you #include a file, the preprocessor replaces the #include directive with the contents of the included file.</li>
                            </ul>
                        <li>#define</li>
                            <ul>
                                <li>The #define directive can be used to create a macro.</li>
                            </ul>
                        <li>Macro</li>
                            <ul>
                                <li>In C++, a <strong>macro</strong> is a rule that defines how input text is converted into replacement output text.</li>
                                <li>Object-like macros with substitution text</li>
                                    <ul>
                                        <li>The preprocessor will replace any futher occurence of the identifier (normally in all capital letters and use underscores to represent spaces)
                                             by the <span style="font-style: italic;">substitution text</span>.</li>
                                        <li>The text substitution action will not affect other preprocessor directives.</li>
                                        <pre>
                                            <code>
    #include &lt;iostream>
    #define MY_NAME "ALEX"
    int main() &#123;
        std::cout &lt;&lt; "My name is: " &lt;&lt; MY_NAME;
    }
                                            </code>
                                        </pre>
                                    </ul>
                                <li>Object-like macros without substitution text</li>
                                    <ul>
                                        <li>This is useless for doing text substitution but it is used for conditional compilation.</li>
                                        <li>#define USE_YEN // example</li>
                                    </ul>
                            </ul>
                        <li>Conditional Compilation</li>
                            <ul>
                                <li>The commonly used conditional compilation directives are:</li>
                                    <ul>
                                        <li>#ifdef</li>
                                        <li>#ifndef</li>
                                        <li>#endif</li>
                                        <li>#if 0</li>
                                    </ul>
                                <li>Example:</li>
                                    <pre>
                                        <code>
    #include &lt;iostream>

    #define PRINT_JOE
        
    int main() &#123;
        #ifdef PRINT_JOE
            std::cout &lt;&lt; "Joe is defined\n"; // if PRINT_JOE is defined, compile this code
        #endif
            
        #ifndef PRINT_BOB
            std::cout &lt;&lt; "Bob is not defined\n"; // if PRINT_BOB is defined, compile this code
        #endif

        #if 0 // Don't compile anything starting here
            std::cout &lt;&lt; "Test 123\n";
        #endif // until this point
            
        return 0;
    }
                                        </code>
                                    </pre>
                                <li><span style="background-color: whitesmoke; font-style: italic;">#ifdef PRINT_BOB</span> can also be written as <span style="background-color: whitesmoke; font-style: italic;">#if defined(PRINT_BOB)</span></li>
                            </ul>
                        <li>Directives defined in one code file do not have impact on other code files in the same project. In other words, they are not in global scope.</li>
                    </ul>
                <li>Header files</li>
                    <ul>
                        <li>Best practice: Use a .h suffix when naming your header files.</li>
                        <li>Best practice: When including a header file from the standard library, use the version without the .h extension if it exists.</li>
                        <li>Best practice: DO NOT put any function definition in header files.</li>
                        <li>Best practice: If a header file is paired with a code file (e.g. add.h with add.cpp), they should both have the same base name (add).</li>
                        <li>Best practice: Code files should #include their paired header file (if one exists).</li>
                        <pre>
                            <code>
    // IN add.h
    int add (int x, int y)

    // IN add.cpp
    #include "add.h"
    int add (int x, int y) &#123;
        return x + y;
    }

    // IN main.cpp
    #include "add.h"         // double quotes
    #include &lt;iostream>      // angled quotes, and without .h extension
    
    int main()
    &#123;
        std::cout &lt;&lt; "The sum of 3 and 4 is " &lt;&lt; add(3, 4) &lt;&lt; '\n';
        return 0;
    }
                            </code>
                        </pre>
                        <li>Angled brackets vs double quotes</li>
                            <ul>
                                <li>When we use angled brackets, we’re telling the preprocessor that this is a header file we didn’t write ourselves.</li>
                                <ul>
                                    <li>The compiler will search for the header only in the directories specified by the <span style="background-color: whitesmoke; font-style: italic;">include directories</span>.</li>
                                    <li>The <span style="background-color: whitesmoke; font-style: italic;">include directories</span> are configured as part of your project/IDE settings/compiler settings, 
                                        and typically default to the directories containing the header files that come with your compiler and/or OS.</li>
                                    <li>The compiler WILL NOT search for the header file in your project’s source code directory.</li>
                                </ul>
                                <li>When we use double-quotes, we’re telling the preprocessor that this is a header file that we wrote.</li>
                                <ul>
                                    <li>The compiler will first search for the header file in the current directory.</li>
                                    <li>If it can’t find a matching header there, it WILL then search the <span style="background-color: whitesmoke; font-style: italic;">include directories</span>.</li>
                                </ul>
                            </ul>
                        <li>Why doesn’t iostream have a .h extension?</li>
                            <ul>
                                <li>iostream.h and iostream are two different header files.</li>
                                <li>iostream.h was initally used and the iostream is a new header file with std namespace implementation</li>
                                <li>iostream.h is for the support of older programs</li>
                                <li>Hence, when including a header file from the standard library, use the version without the .h extension if it exists.</li>
                            </ul>
                        <li>Best practice: Each file should explicitly #include all the header files needed for its compilation. DO NOT rely on headers included in other some other header files.</li>
                        <li>Best practice: Order your #includes as follows and sort each section alphabetically:
                            <ul>
                                <li>your own user-defined headers</li>
                                <li>3rd party library headers</li>
                                <li>standard library headers</li>
                            </ul>
                        </li>
                    </ul>
                <li>Header Guards</li>
                    <ul>
                        <li>As header files may include other headers, it is possible that we include a same header multiple times, and this will lead to compilation error due to duplicate definition.</li>
                        <li>Hence, we need <strong>Header Guards</strong>, which are the conditional compilation directives.</li>
                        <li>Example:</li>
                            <pre>
                                <code>
    // IN add.h
    #ifndef ADD_H
    #define ADD_H
    int add(int x, int y);
    ##endif

    // IN add.cpp
    #include "add.h"
    int add(int x, int y) &#123;
        return x + y;
    }

    // IN main.cpp
    #include "add.h"
    #include &lt;iostream>
    
    int main() &#123;
        std::cout &lt;&lt; "1 + 2 = " &lt;&lt; add(1,2) &lt;&lt; '\n';
    
        return 0;
    }
                                </code>
                            </pre>
                        <li>#pragma once</li>
                            <ul>
                                <li><span style="background-color: whitesmoke; font-style: italic;">#pragma once</span> is an alternative type of header guards</li>
                                <li>However, <span style="background-color: whitesmoke; font-style: italic;">#pragma once</span> is NOT an official part of the C++ language, and not all compilers support it (although most modern compilers do).</li>
                                <li>Best practice: For compatibility purposes, stick to traditional header guards.</li>
                            </ul>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter3">
            <h2>Chapter 3: Debugging C++ Programs</h2>
            <p>Debugging is general skill and debugging skill should be polished through hands-on. Hence, not many notes for this chapter.</p>
            <ul>
                <li>A <strong>syntax error</strong> occurs when you write a statement that is not valid according to the grammar of the C++ language.</li>
                <li>A <strong>semantic error</strong> occurs when a statement is syntactically valid, but does not do what the programmer intended.</li>
            </ul>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter4">
            <h2>Chapter 4: Fundamental Data Types</h2>
            <ul>
                <li>Bits, bytes, and memory addressing</li>
                    <ul>
                        <li>The smallest unit of memory is a binary digit (also called a bit)</li>
                        <li>Memory is organized into sequential units called memory addresses</li>
                        <li>Each memory address holds 1 byte of data (1 byte = 8 sequential bits)</li>
                        <li>In C++, we typically work with “byte-sized” chunks of data.</li>
                    </ul>
                <li>Fundamental data types</li>
                    <ul>
                        <li></li>
                    </ul>
                <li><span style="font-style:italic">#include &lt;cstdint&gt; is the way to import fixed width standard library</span> </li>
                <li>Fixed width integers should be avoided as they may not be defined on all architectures</li>
                <li>FAST and LEAST types can be used instead</li>
                    <pre>
                        <code>
    // USE of FAST and LEAST integers
    std::cout &lt;&lt; "fast 8: " &lt;&lt; sizeof(std::int_fast8_t) * 8 &lt;&lt; " bits\n";
    std::cout &lt;&lt; "fast 16: " &lt;&lt; sizeof(std::int_fast16_t) * 8 &lt;&lt; " bits\n";
    std::cout &lt;&lt; "fast 32: " &lt;&lt; sizeof(std::int_fast32_t) * 8 &lt;&lt; " bits\n";
    std::cout &lt;&lt; "least 8: " &lt;&lt; sizeof(std::int_least8_t) * 8 &lt;&lt; " bits\n";
    std::cout &lt;&lt; "least 16: " &lt;&lt; sizeof(std::int_least16_t) * 8 &lt;&lt; " bits\n";
    std::cout &lt;&lt; "least 32: " &lt;&lt; sizeof(std::int_least32_t) * 8 &lt;&lt; " bits\n\n";
                        </code>
                    </pre>
                <li></li>
            </ul>
            <mat-divider></mat-divider>
        </div> 
    </div>
    <div (click)="scrollTo('contentList')" class="floatingIconDiv">
        <fa-icon  [icon]="faArrowAltCircleUp" size="2x"></fa-icon>
    </div>
</div>