<div class="flexContainer" id="container">
    <div id="contentList">
        <mat-accordion displayMode="flat" style="padding-left: 5px; padding-right: 5px;">
            <mat-expansion-panel style="margin-top: 5px;">
                <mat-expansion-panel-header>
                    <mat-panel-title>
                        C++
                    </mat-panel-title>
                </mat-expansion-panel-header>
                <button mat-button class="listItem" (click)="scrollTo('chapter1')">Chapter 1: C++ Basics</button>
                <button mat-button class="listItem" (click)="scrollTo('chapter2')">Chapter 2: Functions and Files</button>
                <button mat-button class="listItem" (click)="scrollTo('chapter3')">Chapter 3: Debugging C++ Programs</button>
                <button mat-button class="listItem" (click)="scrollTo('chapter4')">Chapter 4: Fundamental Data Types</button>
            </mat-expansion-panel>
        </mat-accordion>
    </div>
    <div fxLayout="column" fxLayout="column">
        <div>
            <h1>C++</h1>
            <h2>Introduction</h2>
            <p>The following are mainly the notes summarized from <a href="https://www.learncpp.com/" target="_blank" rel="noopener noreferrer">learncpp.com</a>.</p>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter1">
            <h2>Chapter 1: C++ Basics</h2>
            <ul>
                <li>Every C++ program must have a special function named main (all lower case letters).</li>
                <li>In C++, an <strong>object</strong> is a region of storage (usually memory) that has a value and other associated properties.</li>
                <li>A named object is called a <strong>variable</strong>, and the name of the object is called an <strong>identifier</strong></li>
                <li>In C++, the type of a variable must be known at compile-time (when the program is compiled), and that type can not be changed without recompiling the program.</li>
                <li>4 ways to initialize variables in C++</li>
                    <ul>
                        <li>int a; // Uninitalizaed (ERROR)</li>
                        <li>int b = 5; // Copy Initialization (NOT RECOMMENDED)</li>
                        <li>int c(6); // Direct Initialization (NOT RECOMMENDED)</li>
                        <li>int d&#123;7}; // List Initilization or Uniform Initilization (RECOMMENDED)</li>
                    </ul>
                <li>List initialization has the added benefit of disallowing “narrowing” conversions, whereas copy initialization and direct initialization only prompt warning.</li>
                <ul>
                    <li>int a = 3.5; // will have warning</li>
                    <li>int b(3.5); // will have warning</li>
                    <li>int c&#123;3.5}; // will have error</li>
                </ul>
                <li>Initializing variables with empty braces &#123;} will initialize the variable to either zero or empty</li>
                <li>Using '\n' is typically preferred as compared to std::endl because the later has an extra unnecessary action of flushing the output.</li>
                <li>Using this statement as example: int x&#123;2 + 3}</li>
                    <ul>
                        <li>'2' and '3' are <strong>literal</strong></li>
                        <li>'+' is <strong>operator</strong></li>
                        <li>'2 + 3' is <strong>expression</strong></li>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter2">
            <h2>Chapter 2: Functions and Files</h2>
            <ul>
                <li>Nested functions are not supported in C++</li>
                <li>Your main function should return 0 if the program ran normally.</li>
                <li>The C++ standard only defines the meaning of 3 status codes:
                    <ul>
                        <li>0 >> means the program executed successfully</li>
                        <li>EXIT_SUCCESS >> means the program executed successfully</li>
                        <li>EXIT_FAILURE >> means the program did not executed successfully</li>
                    </ul>
                </li>
                <li>Failure to return a value from a function with a non-void return type (other than main) will result in undefined behavior.</li>
                <li>A <strong>function parameter</strong> is a variable used in a function.</li>
                <li>An <strong>argument</strong> is a value that is passed from the caller to the function</li>
                <li>The C++ specification does not define whether function calls evaluate arguments left to right or right to left. 
                    Take care not to make function calls where argument order matters.</li>
                <li>Always do a <strong>forward declaration</strong> to tell the compiler about the existence of an identifier (including function) before actually defining the identifier.</li>
                <li>Example:</li>
                <pre>
                    <code>
    #include &lt;iostream>
    int getValueFromUser(); // forward declaration
    int multiplyBy2(int num); // forward declaration

    int main()
    &#123;
        int num&#123; getValueFromUser() }; // initialize num with the return value of getValueFromUser()
        std::cout &lt;&lt; num &lt;&lt; " doubled is: " &lt;&lt; multiplyBy2(num) &lt;&lt; '\n'; // num here is called argument
        return 0;
    }

    int getValueFromUser()
    &#123;
        std::cout &lt;&lt; "Enter an integer: ";
        int input&#123;};
        std::cin >> input;

        return input;
    }

    // num here is called parameter
    int multiplyBy2(int num) &#123;
        return num * 2;
    }
                    </code>
                </pre>
                <li>Declaration vs Definition</li>
                    <ul>
                        <li>A <strong>declaration</strong> is a statement that tells the compiler about the existence of an identifier
                            and its type information.</li>
                        <li>A <strong>definition</strong> actually implements (for functions or types) or instantiates (for variables) the identifier.</li>
                    </ul>
                <li>Namespace</li>
                    <ul>
                        <li>A <strong>namespace</strong> is a declarative region that provides a scope (called namespace scope) to the identifiers (the names of types, functions, variables, etc) inside it</li>
                        <li>In C++, any name that is not defined inside a class, function, or a namespace is considered to be part of <strong>global namespace</strong> (sometimes called <strong>global scope</strong>)</li>
                        <li>If there are identical names within an explicit namespace or global namespace, <strong>naming collision</strong> error will be produced.</li>
                        <li>A common namespace that we always use is <span style="font-style: italic;">std</span>, which we always use the :: symbol (scope resolution operator) to link 
                            std namespace and the identifiers within it.</li>
                            <ul>
                                <li>std::cout &lt;&lt; "Hello world!"; // example</li>
                            </ul>
                        <li>Another way to access identifiers inside a namespace is to use a <span style="font-style: italic;">using directive</span> statement (for example: <span style="font-style: italic;">using namespace std;</span>).
                        However, avoid using this as it violates the reason why namespaces were added in the first place.</li>
                    </ul>
                <li>Translation & Preprocessor</li>
                    <ul>
                        <li>Prior to compilation, the code file goes through a phase known as <strong>translation</strong>.</li>
                        <li>The translation phases involves the <strong>preprocessor</strong>, which can be best thought of as a separate program that manipulates the text in each code file.</li>
                        <li><strong>Preprocessor directives</strong> are instructions that start with a # symbol and end with a newline (NOT a semicolon).</li>
                        <li>Directives are resolved before compilation, from top to bottom on a file-by-file basis, therefore the output of the preprocessor contains no directives at all.</li>
                        <li>#include</li>
                            <ul>
                                <li>When you #include a file, the preprocessor replaces the #include directive with the contents of the included file.</li>
                            </ul>
                        <li>#define</li>
                            <ul>
                                <li>The #define directive can be used to create a macro.</li>
                            </ul>
                        <li>Macro</li>
                            <ul>
                                <li>In C++, a <strong>macro</strong> is a rule that defines how input text is converted into replacement output text.</li>
                                <li>Object-like macros with substitution text</li>
                                    <ul>
                                        <li>The preprocessor will replace any futher occurence of the identifier (normally in all capital letters and use underscores to represent spaces)
                                             by the <span style="font-style: italic;">substitution text</span>.</li>
                                        <li>The text substitution action will not affect other preprocessor directives.</li>
                                        <pre>
                                            <code>
    #include &lt;iostream>
    #define MY_NAME "ALEX"
    int main() &#123;
        std::cout &lt;&lt; "My name is: " &lt;&lt; MY_NAME;
    }
                                            </code>
                                        </pre>
                                    </ul>
                                <li>Object-like macros without substitution text</li>
                                    <ul>
                                        <li>This is useless for doing text substitution but it is used for conditional compilation.</li>
                                        <li>#define USE_YEN // example</li>
                                    </ul>
                            </ul>
                        <li>Conditional Compilation</li>
                            <ul>
                                <li>The commonly used conditional compilation directives are:</li>
                                    <ul>
                                        <li>#ifdef</li>
                                        <li>#ifndef</li>
                                        <li>#endif</li>
                                        <li>#if 0</li>
                                    </ul>
                                <li>Example:</li>
                                    <pre>
                                        <code>
    #include &lt;iostream>

    #define PRINT_JOE
        
    int main() &#123;
        #ifdef PRINT_JOE
            std::cout &lt;&lt; "Joe is defined\n"; // if PRINT_JOE is defined, compile this code
        #endif
            
        #ifndef PRINT_BOB
            std::cout &lt;&lt; "Bob is not defined\n"; // if PRINT_BOB is defined, compile this code
        #endif

        #if 0 // Don't compile anything starting here
            std::cout &lt;&lt; "Test 123\n";
        #endif // until this point
            
        return 0;
    }
                                        </code>
                                    </pre>
                                <li><span style="background-color: whitesmoke; font-style: italic;">#ifdef PRINT_BOB</span> can also be written as <span style="background-color: whitesmoke; font-style: italic;">#if defined(PRINT_BOB)</span></li>
                            </ul>
                        <li>Directives defined in one code file do not have impact on other code files in the same project. In other words, they are not in global scope.</li>
                    </ul>
                <li>Header files</li>
                    <ul>
                        <li>Best practice: Use a .h suffix when naming your header files.</li>
                        <li>Best practice: When including a header file from the standard library, use the version without the .h extension if it exists.</li>
                        <li>Best practice: DO NOT put any function definition in header files.</li>
                        <li>Best practice: If a header file is paired with a code file (e.g. add.h with add.cpp), they should both have the same base name (add).</li>
                        <li>Best practice: Code files should #include their paired header file (if one exists).</li>
                        <pre>
                            <code>
    // IN add.h
    int add (int x, int y)

    // IN add.cpp
    #include "add.h"
    int add (int x, int y) &#123;
        return x + y;
    }

    // IN main.cpp
    #include "add.h"         // double quotes
    #include &lt;iostream>      // angled quotes, and without .h extension
    
    int main()
    &#123;
        std::cout &lt;&lt; "The sum of 3 and 4 is " &lt;&lt; add(3, 4) &lt;&lt; '\n';
        return 0;
    }
                            </code>
                        </pre>
                        <li>Angled brackets vs double quotes</li>
                            <ul>
                                <li>When we use angled brackets, we’re telling the preprocessor that this is a header file we didn’t write ourselves.</li>
                                <ul>
                                    <li>The compiler will search for the header only in the directories specified by the <span style="background-color: whitesmoke; font-style: italic;">include directories</span>.</li>
                                    <li>The <span style="background-color: whitesmoke; font-style: italic;">include directories</span> are configured as part of your project/IDE settings/compiler settings, 
                                        and typically default to the directories containing the header files that come with your compiler and/or OS.</li>
                                    <li>The compiler WILL NOT search for the header file in your project’s source code directory.</li>
                                </ul>
                                <li>When we use double-quotes, we’re telling the preprocessor that this is a header file that we wrote.</li>
                                <ul>
                                    <li>The compiler will first search for the header file in the current directory.</li>
                                    <li>If it can’t find a matching header there, it WILL then search the <span style="background-color: whitesmoke; font-style: italic;">include directories</span>.</li>
                                </ul>
                            </ul>
                        <li>Why doesn’t iostream have a .h extension?</li>
                            <ul>
                                <li>iostream.h and iostream are two different header files.</li>
                                <li>iostream.h was initally used and the iostream is a new header file with std namespace implementation</li>
                                <li>iostream.h is for the support of older programs</li>
                                <li>Hence, when including a header file from the standard library, use the version without the .h extension if it exists.</li>
                            </ul>
                        <li>Best practice: Each file should explicitly #include all the header files needed for its compilation. DO NOT rely on headers included in other some other header files.</li>
                        <li>Best practice: Order your #includes as follows and sort each section alphabetically:
                            <ul>
                                <li>your own user-defined headers</li>
                                <li>3rd party library headers</li>
                                <li>standard library headers</li>
                            </ul>
                        </li>
                    </ul>
                <li>Header Guards</li>
                    <ul>
                        <li>As header files may include other headers, it is possible that we include a same header multiple times, and this will lead to compilation error due to duplicate definition.</li>
                        <li>Hence, we need <strong>Header Guards</strong>, which are the conditional compilation directives.</li>
                        <li>Example:</li>
                            <pre>
                                <code>
    // IN add.h
    #ifndef ADD_H
    #define ADD_H
    int add(int x, int y);
    ##endif

    // IN add.cpp
    #include "add.h"
    int add(int x, int y) &#123;
        return x + y;
    }

    // IN main.cpp
    #include "add.h"
    #include &lt;iostream>
    
    int main() &#123;
        std::cout &lt;&lt; "1 + 2 = " &lt;&lt; add(1,2) &lt;&lt; '\n';
    
        return 0;
    }
                                </code>
                            </pre>
                        <li>#pragma once</li>
                            <ul>
                                <li><span style="background-color: whitesmoke; font-style: italic;">#pragma once</span> is an alternative type of header guards</li>
                                <li>However, <span style="background-color: whitesmoke; font-style: italic;">#pragma once</span> is NOT an official part of the C++ language, and not all compilers support it (although most modern compilers do).</li>
                                <li>Best practice: For compatibility purposes, stick to traditional header guards.</li>
                            </ul>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter3">
            <h2>Chapter 3: Debugging C++ Programs</h2>
            <p>Debugging is general skill and debugging skill should be polished through hands-on. Hence, not many notes for this chapter.</p>
            <ul>
                <li>A <strong>syntax error</strong> occurs when you write a statement that is not valid according to the grammar of the C++ language.</li>
                <li>A <strong>semantic error</strong> occurs when a statement is syntactically valid, but does not do what the programmer intended.</li>
            </ul>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter4">
            <h2>Chapter 4: Fundamental Data Types</h2>
            <ul>
                <li>Bits, bytes, and memory addressing</li>
                    <ul>
                        <li>The smallest unit of memory is a binary digit (also called a bit)</li>
                        <li>Memory is organized into sequential units called memory addresses</li>
                        <li>Each memory address holds 1 byte of data (1 byte = 8 sequential bits)</li>
                        <li>In C++, we typically work with “byte-sized” chunks of data.</li>
                    </ul>
                <li>_t suffix</li>
                    <ul>
                        <li>Many of the types defined in newer versions of C++ (e.g. std::nullptr_t) use a _t suffix.</li>
                        <li>This suffix means “type”, and it’s a common nomenclature applied to modern types.</li>
                    </ul>
                <li>Object sizes and the sizeof operator</li>
                    <ul>
                        <li>A single object may use 2, 4, 8, or even more consecutive memory addresses. </li>
                        <li>The amount of memory that an object uses is based on its data type.</li>
                        <li>The size of a given data type is dependent on the compiler and/or the computer architecture!</li>
                        <li>C++ only guarantees that each fundamental data types will have a minimum size:</li>
                            <table style="margin: 10px; overflow: auto; width: 100%;">
                                <tr class="trFlex">
                                    <th class="thQuarter">Category</th>
                                    <th class="thQuarter">Types</th>
                                    <th class="thQuarter">Minumum Size</th>
                                    <th class="thQuarter">Note</th>
                                </tr>
                                <tr class="trFlex">
                                    <td class="tdQuarter">Integral (Boolean)</td>
                                    <td class="tdQuarter">bool</td>
                                    <td class="tdQuarter">1 byte</td>
                                    <td class="tdQuarter"></td>
                                </tr>
                                <tr class="trFlex">
                                    <td class="tdQuarter">
                                        Integral (Character)
                                    </td>
                                    <td class="tdQuarter">
                                        <div>char</div>
                                        <div>wchar_t</div>
                                        <div>char8_t</div>
                                        <div>char16_t</div>
                                        <div>char32_t</div>
                                    </td>
                                    <td class="tdQuarter">
                                        <div>1 byte</div>
                                        <div>2 bytes</div>
                                        <div>1 byte</div>
                                        <div>2 bytes</div>
                                        <div>4 bytes</div>
                                    </td>
                                    <td class="tdQuarter">
                                        <div>Always 1 byte</div>
                                        <div>-</div>
                                        <div>-</div>
                                        <div>-</div>
                                        <div>-</div>
                                    </td>
                                </tr>
                                <tr class="trFlex">
                                    <td class="tdQuarter">Integral (Integer)</td>
                                    <td class="tdQuarter">
                                        <div>short</div>
                                        <div>int</div>
                                        <div>long</div>
                                        <div>long long</div>
                                    </td>
                                    <td class="tdQuarter">
                                        <div>2 bytes</div>
                                        <div>2 bytes</div>
                                        <div>4 bytes</div>
                                        <div>8 bytes</div>
                                    </td>
                                    <td class="tdQuarter"></td>
                                </tr>
                                <tr class="trFlex">
                                    <td class="tdQuarter">Floating Point</td>
                                    <td class="tdQuarter">
                                        <div>float</div>
                                        <div>double</div>
                                        <div>long double</div>
                                    </td>
                                    <td class="tdQuarter">
                                        <div>4 bytes</div>
                                        <div>8 bytes</div>
                                        <div>8 bytes</div>
                                    </td>
                                    <td class="tdQuarter"></td>
                                </tr>
                            </table>
                        <li>Best practice: For maximum compatibility, you shouldn’t assume that variables are larger than the specified minimum size.</li>
                        <li>The <strong>sizeof operator</strong> can be used to get the size in bytes of a date type or variable.</li>
                    </ul>
                <li>integers</li>
                    <ul>
                        <li>By default, integers are <strong>signed</strong>, which means the number’s sign is stored as part of the number (using a single bit called the sign bit).</li>
                        <li>An n-bit signed variable has a range of -(2<sup>n-1</sup>) to 2<sup>n-1</sup>-1.</li>
                        <li><strong>Integer overflow</strong> occurs when we try to store a value that is outside the range of the type.</li>
                        <li><strong>Warning: </strong>Signed integer overflow will result in undefined behavior.</li>
                        <li><strong>Warning: </strong>When doing division with two integers (called integer division), C++ always produces an integer result. 
                            Since integers can’t hold fractional values, any fractional portion is simply dropped (not rounded!).</li>
                    </ul>
                <li>unsigned integers</li>
                    <ul>
                        <li>An n-bit unsigned variable has a range of 0 to (2<sup>n</sup>)-1.</li>
                        <li>To define an unsigned integer, we use the unsigned keyword. By convention, this is placed before the type:</li>
                        <li>Unsigned integer overflow</li>
                            <ul>
                                <li>When unsigned integer overflow happens, the value can be determined and it is not undefined dehaviour.</li>
                                <li>The result of overflowed unsigned integer will be the overflow value divided by number of integers it can present, and only the remainder kept.</li>
                                <li>For example, 1-byte unsigned integer has a range of 0 - 255, if the unsigned integer overflows to 256, it will be 0,
                                    and if it overflows to 513, the value will be 1.
                                </li>
                                <li>In another way round, -negative numbers will be wrapped also. For example, setting a 1-byte unsigned integer to -1 will get 255.</li>
                                <li><strong>Warning: </strong>Avoid using unsigned numbers, except in specific cases or when unavoidable.</li>
                                <li><strong>Warning: </strong>If you do use unsigned numbers, avoid mixing signed and unsigned numbers where possible.</li>
                                <li>However, unsigned numbers are preferred when:</li>
                                    <ul>
                                        <li>dealing with bit manipulation</li>
                                        <li>array indexing</li>
                                        <li>dealing with embedded system for performance reasons</li>
                                    </ul>
                            </ul>
                    </ul>
                <li>Fixed-width integers and size_t</li>
                    <ul>
                        <li>C++ only guarantees that integer variables will have a minimum size -- but they could be larger, depending on the target system.</li>
                        <li>When dealing with types that have uncertain ranges, it is possible that a program might work on one architecture but no on another due to
                            difference in the range that they support.
                        </li>
                        <li>To help with cross-platform portability, C99 defined a set of <strong>fixed-width integers</strong> (in the stdint.h header) that are guaranteed to have the same size on any architecture.</li>
                        <li><strong>Warning: </strong>Using fixed-width integers doesn't guarantee faster processing, it may be slower, it's depending on the architectures.</li>
                        <li><strong>Warning: </strong>Fixed-width integers should be avoided, as they may not be defined on all target architectures.</li>
                    </ul>
                <li>Fast and least integers</li>
                    <ul>
                        <li>The <strong>fast type</strong> (std::int_fast#_t) provides the fastest signed integer type with a width of at least # bits (where # = 8, 16, 32, or 64).</li>
                        <li>The <strong>least type</strong> (std::int_least#_t) provides the smallest signed integer type with a width of at least # bits (where # = 8, 16, 32, or 64).</li>
                        <pre style="margin: 0px">
                            <code>
    #include &lt;cstdint>
    #inlcude &lt;iostream>
    
    int main() &#123;
        std::cout &lt;&lt; "fast 8: " &lt;&lt; sizeof(std::int_fast8_t) * 8 &lt;&lt; " bits\n";
        std::cout &lt;&lt; "fast 16: " &lt;&lt; sizeof(std::int_fast16_t) * 8 &lt;&lt; " bits\n";
        std::cout &lt;&lt; "fast 32: " &lt;&lt; sizeof(std::int_fast32_t) * 8 &lt;&lt; " bits\n";
        std::cout &lt;&lt; "least 8: " &lt;&lt; sizeof(std::int_least8_t) * 8 &lt;&lt; " bits\n";
        std::cout &lt;&lt; "least 16: " &lt;&lt; sizeof(std::int_least16_t) * 8 &lt;&lt; " bits\n";
        std::cout &lt;&lt; "least 32: " &lt;&lt; sizeof(std::int_least32_t) * 8 &lt;&lt; " bits\n\n";
        return 0
    }
                            </code>
                        </pre>
                        <li>These fast and least types are guaranteed to be defined, and are safe to use.</li>
                        <li>Best practice: Favor the std::int_fast#_t and std::int_least#_t integers when you need an integer guaranteed to be at least a certain minimum size.</li>
                    </ul>
                    <li><strong>Warning: </strong>std::int8_t and std::uint8_t may behave like chars instead of integers</li>
                        <ul>
                            <li>For example, for the case below, most systems will print 'A' and only some systems may print 65.</li>
                            <pre style="margin: 0px">
                                <code>
    std::int8_t myint&#123;65};
    std::cout &lt;&lt; myint;                                
                                </code>
                            </pre>
                            <li><strong>Warning: </strong>Avoid the 8-bit fixed-width integer types. If you do use them, note that they are often treated like chars.</li>
                        </ul>
                    <li>Integer best practices</li>
                        <ul>
                            <li>Use int when the size of the integer doesn’t matter (numbers always fit within the range of -65535 to 65535)</li>           
                            <li>For guaranteed size and better performance, use std::int_fast#_t.</li>
                            <li>For guaranteed size and better memory conservation, use std::int_least#_t.</li>
                            <li>Avoid unsigned types unless really needed.</li>
                            <li>Avoid 8-bit fixed-width integer types.</li>
                            <li>Avoid compiler-specific fixed-width integers, for example, Visual Studio defines __int8, __int16, etc</li>
                        </ul>
                    <li>Scientic Notation</li>
                        <ul>
                            <li>Numbers in scientific notation take the following form: significand x 10<sup>exponent</sup></li>
                            <li>For example: 1.2 x 10<sup>4</sup></li>
                            <li>In C++, the letter ‘e’ (or sometimes ‘E’) is used to represent the “times 10 to the power of” part of the equation</li>
                            <li>For example: 5.9736 x 10<sup>24</sup> could be written as 5.9736e24</li>
                            <li>The digits in the significand (the part before the ‘e’) are called the significant digits. </li>
                            <li>In standard scientfic notation, the trailing zeros after a decimal point represents the precision of a number. 
                                However, in C++, 88 and 88.000 are treated exactly the same by the compiler.</li>
                        </ul>
                    <li>Floating point numbers</li>
                        <ul>
                            <li>A floating point type variable is a variable that can hold a real number, such as 4320.0, -3.33, or 0.01226.</li>
                            <li>There are three different floating point data types: <strong>float</strong>, <strong>double</strong>, and <strong>long double</strong>.</li>
                            <li>Floating point data types are always signed</li>
                            <li>When using floating point literals, always include at least one decimal place (even if the decimal is 0). 
                                This helps the compiler understand that the number is a floating point number and not an integer.</li>
                            <li>By default, floating point literals default to type double. An f suffix is used to denote a literal of type float.</li>
                            <li>Best Practice: Always make sure the type of your literals match the type of the variables they’re being assigned to or used to initialize. Otherwise an unnecessary conversion will result, possibly with a loss of precision.</li>
                            <pre>
                                <code>
    int v&#123; 5.0 }; // will have conversion error
    int w&#123; 5 }; 
    double x&#123; 5 }; // avoid using integer literals for floating point variables
    double y&#123; 5.0 }; // no suffix means double type by default
    float z&#123; 5.0f }; // f suffix means float type
    std::cout &lt;&lt; x &lt;&lt; "\n"; // output: 5
    std::cout &lt;&lt; y &lt;&lt; "\n"; // output: 5
    std::cout &lt;&lt; z &lt;&lt; "\n"; // output: 5
    std::cout &lt;&lt; 5.0 &lt;&lt; '\n'; // output: 5
    std::cout &lt;&lt; 6.7f &lt;&lt; '\n'; // output: 6.7
    std::cout &lt;&lt; 9876543.21 &lt;&lt; '\n'; // output: 9.87654e+06
                                </code>
                            </pre>
                            <li>When outputting floating point numbers, std::cout has a default precision of 6 -- that is, 
                                it assumes all floating point variables are only significant to 6 digits (the minimum precision of a float), and hence it will truncate anything after that.</li>
                            <li>We can override the default precision that std::cout shows by using an output manipulator function named <strong>std::setprecision()</strong></li>
                            <li>floating numbers precision:</li>
                                <ul>
                                    <li>Float values have between 6 and 9 digits of precision.</li>
                                    <li>Double values have between 15 and 18 digits of precision.</li>
                                    <li>Long double has a minimum precision of 15, 18, or 33 significant digits</li>
                                </ul>
                            <li>Best practice: Favor double over float unless space is at a premium, as the lack of precision in a float will often lead to inaccuracies.</li>
                            <pre>
                                <code>
    #include &lt;iomanip>
    #include &lt;iostream>

    int main() &#123;
        std::cout &lt;&lt; std::setprecision(16); // show 16 digits of precision
        std::cout &lt;&lt; 3.33333333333333333333333333333333333333f &lt;&lt; '\n'; // output: 3.333333253860474 (float has lower precision, hence more errors)
        std::cout &lt;&lt; 3.33333333333333333333333333333333333333 &lt;&lt; '\n'; // output: 3.333333333333333
        float f&#123; 123456789.0f };
        std::cout &lt;&lt; std::setprecision(9); // to show 9 digits in f
        std::cout &lt;&lt; f &lt;&lt; '\n';
        // output: 123456792 // float only has 7 digits of precision, hence it is only precise to 7 significant figures

        return 0;
    }
                                </code>
                            </pre>
                            <li><strong>Warning: </strong>Never assume your floating point numbers are exact.</li>
                            <pre>
                                <code>
    double d1&#123; 1.0 };
    std::cout &lt;&lt; d1 &lt;&lt; '\n'; // output: 1
    double d2&#123; 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1}; // should be equal to 1.0
    std::cout &lt;&lt; std::setprecision(17);
    std::cout &lt;&lt; d2 &lt;&lt; '\n'; // output: 0.99999999999999989
                                </code>
                            </pre>
                        </ul>
                <li>NaN & Inf</li>
                    <ul>
                        <li><strong>NaN</strong>, stands for “Not a Number”</li>
                        <li><strong>Inf</strong>, represents infinity, can be positive or negative</li>
                        <li>NaN and Inf are only available if the compiler uses a specific format (IEEE 754) for floating point numbers.</li>
                        <li>The following are results using Visual Studio 2019 on Windows</li>
                            <pre>
                                <code>
    double posinf &#123; 5.0 / zero }; // positive infinity
    std::cout &lt;&lt; posinf &lt;&lt; '\n'; // output: inf

    double neginf &#123; -5.0 / zero }; // negative infinity
    std::cout &lt;&lt; neginf &lt;&lt; '\n'; // output: -inf

    double nan &#123; zero / zero }; // not a number (mathematically invalid)
    std::cout &lt;&lt; nan &lt;&lt; '\n'; // output: -nan(ind)
                                </code>
                            </pre>
                        <li>Best practice: Avoid division by 0 altogether, even if your compiler supports it.</li>
                    </ul>
                <li>Boolean values</li>
                    <ul>
                        <li>Boolean variables can have only two possible values: true, and false.</li>
                        <li>To declare a Boolean variable, we use the keyword bool.</li>
                        <li>In C++, std::cout prints 0 for false, and 1 for true:</li>
                        <li>If you want std::cout to print “true” or “false” instead of 0 or 1, you can use std::boolalpha.</li>
                        <li>To make std::cin accept “false” and “true” as inputs, need to enable the std::boolalpha option as well.</li>
                        <pre>
                            <code>
    std::cout &lt;&lt; true &lt;&lt; '\n'; // output: 0
    std::cout &lt;&lt; false &lt;&lt; '\n'; // output: 1
    std::cout &lt;&lt; std::boolalpha; // enable cout std::boolalpha
    std::cout &lt;&lt; true &lt;&lt; '\n'; // output: true
    std::cout &lt;&lt; false &lt;&lt; '\n'; // output: false
    bool b&#123;}; // default initialize to false
    std::cout &lt;&lt; "Enter a boolean value: ";
    std::cin >> std::boolalpha; // enable cin std::boolalpha
    std::cin >> b; // input: 'true'
    std::cout &lt;&lt; b &lt;&lt; '\n'; // output: true 
                            </code>
                        </pre>
                    </ul>
                <li>Chars</li>
                    <ul>
                        <li>The <strong>char</strong> data type was designed to hold a character.</li>
                        <li>A character can be a single letter, number, symbol, or whitespace.</li>
                        <li>The char data type is an integral type, meaning the underlying value is stored as an integer.</li>
                        <li>The integer stored by a char variable are intepreted as an ASCII character.</li>
                        <li>Character literals are always placed between single quotes (e.g. ‘g’, ‘1’, ‘ ‘).</li>
                        <li>Key insight: Whenever you see C++ syntax (excluding the preprocessor) that makes use of angled brackets, 
                            the thing between the angled brackets will most likely be a type.
                            This is typically how C++ deals with concepts that need a parameterizable type.</li>
                        <li>Char variables can only hold 1 character, if you input more than one characters in std::cin, 
                            it will put the rest in input buffer.</li>
                        <li>Char is defined by C++ to always be 1 byte in size.</li>
                        <li>By default, a char may be signed or unsigned (though it’s usually signed).</li>
                        <li>Single Quotes vs Double Quotes</li>
                            <ul>
                                <li>Stand-alone chars are always put in single quotes</li>
                                <li>Text put between double quotes (e.g. “Hello, world!”) is called a <strong>string</strong></li>
                            </ul>
                        <li>wchar_t, char8_t, char16_t, and char32_t</li>
                            <ul>
                                <li>wchar_t should be avoided in almost all cases (except when interfacing with the Windows API). </li>
                                <li>char16_t and char32_t were added to C++11 to provide explicit support for 16-bit and 32-bit Unicode characters.</li>
                                <li>char8_t has been added in C++20.</li>
                                <li>You won’t need to use char8_t, char16_t, or char32_t unless you’re planning on making your program Unicode compatible.</li>
                            </ul>
                    </ul>
                <li>String</li>
                    <ul>
                        <li>In C++, strings aren’t a fundamental type. Hence, to use strings in C++, we first need to #include the &lt;string> header to bring in the declarations for std::string.</li>
                        <li><strong>Warning: </strong>Don't use std::cin to read strings, use std::getline instead.</li>
                        <li>Best practice: If using std::getline to read strings, use the <strong>std::ws</strong> input manipulator to ignore leading whitespace. For detailed reason, 
                        refer to <a href="https://www.learncpp.com/cpp-tutorial/an-introduction-to-stdstring/" target="_blank" rel="noopener noreferrer">this tutorial</a>.</li>
                        <pre>
                            <code>
    #include &lt;string>
    #include &lt;iostream>
    
    int main() &#123;
        std::cout &lt;&lt; "Now enter your name: ";
        std::string name&#123;};
        std::getline(std::cin >> std::ws, name); // note: added std::ws here
        std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; '\n';
        return 0;
    }
                            </code>
                        </pre>
                        <li>.length() can be used to get the length of a string</li>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div> 
    </div>
    <div (click)="scrollTo('contentList')" class="floatingIconDiv">
        <fa-icon  [icon]="faArrowAltCircleUp" size="2x"></fa-icon>
    </div>
</div>