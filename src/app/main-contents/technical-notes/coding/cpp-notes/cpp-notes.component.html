<div class="flexContainer" id="container">
    <div id="contentList">
        <mat-accordion displayMode="flat" style="padding-left: 5px; padding-right: 5px;">
            <mat-expansion-panel style="margin-top: 5px;">
                <mat-expansion-panel-header>
                    <mat-panel-title>
                        C++
                    </mat-panel-title>
                </mat-expansion-panel-header>
                <button mat-button class="listItem" (click)="scrollTo('chapter1')">Chapter 1: C++ Basics</button>
                <button mat-button class="listItem" (click)="scrollTo('chapter2')">Chapter 2: Functions and Files</button>
                <button mat-button class="listItem" (click)="scrollTo('chapter3')">Chapter 3: Debugging C++ Programs</button>
                <button mat-button class="listItem" (click)="scrollTo('chapter4')">Chapter 4: Fundamental Data Types</button>
            </mat-expansion-panel>
        </mat-accordion>
    </div>
    <div fxLayout="column" fxLayout="column">
        <div>
            <h1>C++</h1>
            <h2>Introduction</h2>
            <p>The following are mainly the notes summarized from <a href="https://www.learncpp.com/" target="_blank" rel="noopener noreferrer">learncpp.com</a>.</p>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter1">
            <h2>Chapter 1: C++ Basics</h2>
            <ul>
                <li>Every C++ program must have a special function named main (all lower case letters).</li>
                <li>In C++, an <strong>object</strong> is a region of storage (usually memory) that has a value and other associated properties.</li>
                <li>A named object is called a <strong>variable</strong>, and the name of the object is called an <strong>identifier</strong></li>
                <li>In C++, the type of a variable must be known at compile-time (when the program is compiled), and that type can not be changed without recompiling the program.</li>
                <li>4 ways to initialize variables in C++</li>
                    <ul>
                        <li>int a; // Uninitalizaed (ERROR)</li>
                        <li>int b = 5; // Copy Initialization (NOT RECOMMENDED)</li>
                        <li>int c(6); // Direct Initialization (NOT RECOMMENDED)</li>
                        <li>int d&#123;7}; // List Initilization or Uniform Initilization (RECOMMENDED)</li>
                    </ul>
                <li>List initialization has the added benefit of disallowing “narrowing” conversions, whereas copy initialization and direct initialization only prompt warning.</li>
                <ul>
                    <li>int a = 3.5; // will have warning</li>
                    <li>int b(3.5); // will have warning</li>
                    <li>int c&#123;3.5}; // will have error</li>
                </ul>
                <li>Initializing variables with empty braces &#123;} will initialize the variable to either zero or empty</li>
                <li>Using '\n' is typically preferred as compared to std::endl because the later has an extra unnecessary action of flushing the output.</li>
                <li>Using this statement as example: int x&#123;2 + 3}</li>
                    <ul>
                        <li>'2' and '3' are <strong>literal</strong></li>
                        <li>'+' is <strong>operator</strong></li>
                        <li>'2 + 3' is <strong>expression</strong></li>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter2">
            <h2>Chapter 2: Functions and Files</h2>
            <ul>
                <li>Nested functions are not supported in C++</li>
                <li>Your main function should return 0 if the program ran normally.</li>
                <li>The C++ standard only defines the meaning of 3 status codes:
                    <ul>
                        <li>0 >> means the program executed successfully</li>
                        <li>EXIT_SUCCESS >> means the program executed successfully</li>
                        <li>EXIT_FAILURE >> means the program did not executed successfully</li>
                    </ul>
                </li>
                <li>Failure to return a value from a function with a non-void return type (other than main) will result in undefined behavior.</li>
                <li>A <strong>function parameter</strong> is a variable used in a function.</li>
                <li>An <strong>argument</strong> is a value that is passed from the caller to the function</li>
                <li>The C++ specification does not define whether function calls evaluate arguments left to right or right to left. 
                    Take care not to make function calls where argument order matters.</li>
                <li>Always do a <strong>forward declaration</strong> to tell the compiler about the existence of an identifier (including function) before actually defining the identifier.</li>
                <li>Example:</li>
                <pre>
                    <code>
    #include &lt;iostream>
    int getValueFromUser(); // forward declaration
    int multiplyBy2(int num); // forward declaration

    int main()
    &#123;
        int num&#123; getValueFromUser() }; // initialize num with the return value of getValueFromUser()
        std::cout &lt;&lt; num &lt;&lt; " doubled is: " &lt;&lt; multiplyBy2(num) &lt;&lt; '\n'; // num here is called argument
        return 0;
    }

    int getValueFromUser()
    &#123;
        std::cout &lt;&lt; "Enter an integer: ";
        int input&#123;};
        std::cin >> input;

        return input;
    }

    // num here is called parameter
    int multiplyBy2(int num) &#123;
        return num * 2;
    }
                    </code>
                </pre>
                <li>Declaration vs Definition</li>
                    <ul>
                        <li>A <strong>declaration</strong> is a statement that tells the compiler about the existence of an identifier
                            and its type information.</li>
                        <li>A <strong>definition</strong> actually implements (for functions or types) or instantiates (for variables) the identifier.</li>
                    </ul>
                <li>Namespace</li>
                    <ul>
                        <li>A <strong>namespace</strong> is a declarative region that provides a scope (called namespace scope) to the identifiers (the names of types, functions, variables, etc) inside it</li>
                        <li>In C++, any name that is not defined inside a class, function, or a namespace is considered to be part of <strong>global namespace</strong> (sometimes called <strong>global scope</strong>)</li>
                        <li>If there are identical names within an explicit namespace or global namespace, <strong>naming collision</strong> error will be produced.</li>
                        <li>A common namespace that we always use is <span style="font-style: italic;">std</span>, which we always use the :: symbol (scope resolution operator) to link 
                            std namespace and the identifiers within it.</li>
                            <ul>
                                <li>std::cout &lt;&lt; "Hello world!"; // example</li>
                            </ul>
                        <li>Another way to access identifiers inside a namespace is to use a <span style="font-style: italic;">using directive</span> statement (for example: <span style="font-style: italic;">using namespace std;</span>).
                        However, avoid using this as it violates the reason why namespaces were added in the first place.</li>
                    </ul>
                <li>Translation & Preprocessor</li>
                    <ul>
                        <li>Prior to compilation, the code file goes through a phase known as <strong>translation</strong>.</li>
                        <li>The translation phases involves the <strong>preprocessor</strong>, which can be best thought of as a separate program that manipulates the text in each code file.</li>
                        <li><strong>Preprocessor directives</strong> are instructions that start with a # symbol and end with a newline (NOT a semicolon).</li>
                        <li>Directives are resolved before compilation, from top to bottom on a file-by-file basis, therefore the output of the preprocessor contains no directives at all.</li>
                        <li>#include</li>
                            <ul>
                                <li>When you #include a file, the preprocessor replaces the #include directive with the contents of the included file.</li>
                            </ul>
                        <li>#define</li>
                            <ul>
                                <li>The #define directive can be used to create a macro.</li>
                            </ul>
                        <li>Macro</li>
                            <ul>
                                <li>In C++, a <strong>macro</strong> is a rule that defines how input text is converted into replacement output text.</li>
                                <li>Object-like macros with substitution text</li>
                                    <ul>
                                        <li>The preprocessor will replace any futher occurence of the identifier (normally in all capital letters and use underscores to represent spaces)
                                             by the <span style="font-style: italic;">substitution text</span>.</li>
                                        <li>The text substitution action will not affect other preprocessor directives.</li>
                                        <pre>
                                            <code>
    #include &lt;iostream>
    #define MY_NAME "ALEX"
    int main() &#123;
        std::cout &lt;&lt; "My name is: " &lt;&lt; MY_NAME;
    }
                                            </code>
                                        </pre>
                                    </ul>
                                <li>Object-like macros without substitution text</li>
                                    <ul>
                                        <li>This is useless for doing text substitution but it is used for conditional compilation.</li>
                                        <li>#define USE_YEN // example</li>
                                    </ul>
                            </ul>
                        <li>Conditional Compilation</li>
                            <ul>
                                <li>The commonly used conditional compilation directives are:</li>
                                    <ul>
                                        <li>#ifdef</li>
                                        <li>#ifndef</li>
                                        <li>#endif</li>
                                        <li>#if 0</li>
                                    </ul>
                                <li>Example:</li>
                                    <pre>
                                        <code>
    #include &lt;iostream>

    #define PRINT_JOE
        
    int main() &#123;
        #ifdef PRINT_JOE
            std::cout &lt;&lt; "Joe is defined\n"; // if PRINT_JOE is defined, compile this code
        #endif
            
        #ifndef PRINT_BOB
            std::cout &lt;&lt; "Bob is not defined\n"; // if PRINT_BOB is defined, compile this code
        #endif

        #if 0 // Don't compile anything starting here
            std::cout &lt;&lt; "Test 123\n";
        #endif // until this point
            
        return 0;
    }
                                        </code>
                                    </pre>
                                <li><span style="background-color: whitesmoke; font-style: italic;">#ifdef PRINT_BOB</span> can also be written as <span style="background-color: whitesmoke; font-style: italic;">#if defined(PRINT_BOB)</span></li>
                            </ul>
                        <li>Directives defined in one code file do not have impact on other code files in the same project. In other words, they are not in global scope.</li>
                    </ul>
                <li>Header files</li>
                    <ul>
                        <li>Best practice: Use a .h suffix when naming your header files.</li>
                        <li>Best practice: When including a header file from the standard library, use the version without the .h extension if it exists.</li>
                        <li>Best practice: DO NOT put any function definition in header files.</li>
                        <li>Best practice: If a header file is paired with a code file (e.g. add.h with add.cpp), they should both have the same base name (add).</li>
                        <li>Best practice: Code files should #include their paired header file (if one exists).</li>
                        <pre>
                            <code>
    // IN add.h
    int add (int x, int y)

    // IN add.cpp
    #include "add.h"
    int add (int x, int y) &#123;
        return x + y;
    }

    // IN main.cpp
    #include "add.h"         // double quotes
    #include &lt;iostream>      // angled quotes, and without .h extension
    
    int main()
    &#123;
        std::cout &lt;&lt; "The sum of 3 and 4 is " &lt;&lt; add(3, 4) &lt;&lt; '\n';
        return 0;
    }
                            </code>
                        </pre>
                        <li>Angled brackets vs double quotes</li>
                            <ul>
                                <li>When we use angled brackets, we’re telling the preprocessor that this is a header file we didn’t write ourselves.</li>
                                <ul>
                                    <li>The compiler will search for the header only in the directories specified by the <span style="background-color: whitesmoke; font-style: italic;">include directories</span>.</li>
                                    <li>The <span style="background-color: whitesmoke; font-style: italic;">include directories</span> are configured as part of your project/IDE settings/compiler settings, 
                                        and typically default to the directories containing the header files that come with your compiler and/or OS.</li>
                                    <li>The compiler WILL NOT search for the header file in your project’s source code directory.</li>
                                </ul>
                                <li>When we use double-quotes, we’re telling the preprocessor that this is a header file that we wrote.</li>
                                <ul>
                                    <li>The compiler will first search for the header file in the current directory.</li>
                                    <li>If it can’t find a matching header there, it WILL then search the <span style="background-color: whitesmoke; font-style: italic;">include directories</span>.</li>
                                </ul>
                            </ul>
                        <li>Why doesn’t iostream have a .h extension?</li>
                            <ul>
                                <li>iostream.h and iostream are two different header files.</li>
                                <li>iostream.h was initally used and the iostream is a new header file with std namespace implementation</li>
                                <li>iostream.h is for the support of older programs</li>
                                <li>Hence, when including a header file from the standard library, use the version without the .h extension if it exists.</li>
                            </ul>
                        <li>Best practice: Each file should explicitly #include all the header files needed for its compilation. DO NOT rely on headers included in other some other header files.</li>
                        <li>Best practice: Order your #includes as follows and sort each section alphabetically:
                            <ul>
                                <li>your own user-defined headers</li>
                                <li>3rd party library headers</li>
                                <li>standard library headers</li>
                            </ul>
                        </li>
                    </ul>
                <li>Header Guards</li>
                    <ul>
                        <li>As header files may include other headers, it is possible that we include a same header multiple times, and this will lead to compilation error due to duplicate definition.</li>
                        <li>Hence, we need <strong>Header Guards</strong>, which are the conditional compilation directives.</li>
                        <li>Example:</li>
                            <pre>
                                <code>
    // IN add.h
    #ifndef ADD_H
    #define ADD_H
    int add(int x, int y);
    ##endif

    // IN add.cpp
    #include "add.h"
    int add(int x, int y) &#123;
        return x + y;
    }

    // IN main.cpp
    #include "add.h"
    #include &lt;iostream>
    
    int main() &#123;
        std::cout &lt;&lt; "1 + 2 = " &lt;&lt; add(1,2) &lt;&lt; '\n';
    
        return 0;
    }
                                </code>
                            </pre>
                        <li>#pragma once</li>
                            <ul>
                                <li><span style="background-color: whitesmoke; font-style: italic;">#pragma once</span> is an alternative type of header guards</li>
                                <li>However, <span style="background-color: whitesmoke; font-style: italic;">#pragma once</span> is NOT an official part of the C++ language, and not all compilers support it (although most modern compilers do).</li>
                                <li>Best practice: For compatibility purposes, stick to traditional header guards.</li>
                            </ul>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter3">
            <h2>Chapter 3: Debugging C++ Programs</h2>
            <p>Debugging is general skill and debugging skill should be polished through hands-on. Hence, not many notes for this chapter.</p>
            <ul>
                <li>A <strong>syntax error</strong> occurs when you write a statement that is not valid according to the grammar of the C++ language.</li>
                <li>A <strong>semantic error</strong> occurs when a statement is syntactically valid, but does not do what the programmer intended.</li>
            </ul>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter4">
            <h2>Chapter 4: Fundamental Data Types</h2>
            <ul>
                <li>Bits, bytes, and memory addressing</li>
                    <ul>
                        <li>The smallest unit of memory is a binary digit (also called a bit)</li>
                        <li>Memory is organized into sequential units called memory addresses</li>
                        <li>Each memory address holds 1 byte of data (1 byte = 8 sequential bits)</li>
                        <li>In C++, we typically work with “byte-sized” chunks of data.</li>
                    </ul>
                <li>_t suffix</li>
                    <ul>
                        <li>Many of the types defined in newer versions of C++ (e.g. std::nullptr_t) use a _t suffix.</li>
                        <li>This suffix means “type”, and it’s a common nomenclature applied to modern types.</li>
                    </ul>
                <li>Object sizes and the sizeof operator</li>
                    <ul>
                        <li>A single object may use 2, 4, 8, or even more consecutive memory addresses. </li>
                        <li>The amount of memory that an object uses is based on its data type.</li>
                        <li>The size of a given data type is dependent on the compiler and/or the computer architecture!</li>
                        <li>C++ only guarantees that each fundamental data types will have a minimum size:</li>
                            <table style="margin: 10px; overflow: auto; width: 100%;">
                                <tr class="trFlex">
                                    <th class="thQuarter">Category</th>
                                    <th class="thQuarter">Types</th>
                                    <th class="thQuarter">Minumum Size</th>
                                    <th class="thQuarter">Note</th>
                                </tr>
                                <tr class="trFlex">
                                    <td class="tdQuarter">Integral (Boolean)</td>
                                    <td class="tdQuarter">bool</td>
                                    <td class="tdQuarter">1 byte</td>
                                    <td class="tdQuarter"></td>
                                </tr>
                                <tr class="trFlex">
                                    <td class="tdQuarter">
                                        Integral (Character)
                                    </td>
                                    <td class="tdQuarter">
                                        <div>char</div>
                                        <div>wchar_t</div>
                                        <div>char8_t</div>
                                        <div>char16_t</div>
                                        <div>char32_t</div>
                                    </td>
                                    <td class="tdQuarter">
                                        <div>1 byte</div>
                                        <div>2 bytes</div>
                                        <div>1 byte</div>
                                        <div>2 bytes</div>
                                        <div>4 bytes</div>
                                    </td>
                                    <td class="tdQuarter">
                                        <div>Always 1 byte</div>
                                        <div>-</div>
                                        <div>-</div>
                                        <div>-</div>
                                        <div>-</div>
                                    </td>
                                </tr>
                                <tr class="trFlex">
                                    <td class="tdQuarter">Integral (Integer)</td>
                                    <td class="tdQuarter">
                                        <div>short</div>
                                        <div>int</div>
                                        <div>long</div>
                                        <div>long long</div>
                                    </td>
                                    <td class="tdQuarter">
                                        <div>2 bytes</div>
                                        <div>2 bytes</div>
                                        <div>4 bytes</div>
                                        <div>8 bytes</div>
                                    </td>
                                    <td class="tdQuarter"></td>
                                </tr>
                                <tr class="trFlex">
                                    <td class="tdQuarter">Floating Point</td>
                                    <td class="tdQuarter">
                                        <div>float</div>
                                        <div>double</div>
                                        <div>long double</div>
                                    </td>
                                    <td class="tdQuarter">
                                        <div>4 bytes</div>
                                        <div>8 bytes</div>
                                        <div>8 bytes</div>
                                    </td>
                                    <td class="tdQuarter"></td>
                                </tr>
                            </table>
                        <li>Best practice: For maximum compatibility, you shouldn’t assume that variables are larger than the specified minimum size.</li>
                        <li>The <strong>sizeof operator</strong> can be used to get the size in bytes of a date type or variable.</li>
                    </ul>
                <li>integers</li>
                    <ul>
                        <li>By default, integers are <strong>signed</strong>, which means the number’s sign is stored as part of the number (using a single bit called the sign bit).</li>
                        <li>An n-bit signed variable has a range of -(2<sup>n-1</sup>) to 2<sup>n-1</sup>-1.</li>
                        <li><strong>Integer overflow</strong> occurs when we try to store a value that is outside the range of the type.</li>
                        <li><strong>Warning: </strong>Signed integer overflow will result in undefined behavior.</li>
                        <li><strong>Warning: </strong>When doing division with two integers (called integer division), C++ always produces an integer result. 
                            Since integers can’t hold fractional values, any fractional portion is simply dropped (not rounded!).</li>
                    </ul>
                <li>unsigned integers</li>
                    <ul>
                        <li>An n-bit unsigned variable has a range of 0 to (2<sup>n</sup>)-1.</li>
                        <li>To define an unsigned integer, we use the unsigned keyword. By convention, this is placed before the type:</li>
                        <li>Unsigned integer overflow</li>
                            <ul>
                                <li>When unsigned integer overflow happens, the value can be determined and it is not undefined dehaviour.</li>
                                <li>The result of overflowed unsigned integer will be the overflow value divided by number of integers it can present, and only the remainder kept.</li>
                                <li>For example, 1-byte unsigned integer has a range of 0 - 255, if the unsigned integer overflows to 256, it will be 0,
                                    and if it overflows to 513, the value will be 1.
                                </li>
                                <li>In another way round, -negative numbers will be wrapped also. For example, setting a 1-byte unsigned integer to -1 will get 255.</li>
                                <li><strong>Warning: </strong>Avoid using unsigned numbers, except in specific cases or when unavoidable.</li>
                                <li><strong>Warning: </strong>If you do use unsigned numbers, avoid mixing signed and unsigned numbers where possible.</li>
                                <li>However, unsigned numbers are preferred when:</li>
                                    <ul>
                                        <li>dealing with bit manipulation</li>
                                        <li>array indexing</li>
                                        <li>dealing with embedded system for performance reasons</li>
                                    </ul>
                            </ul>
                    </ul>
                <li>Fixed-width integers and size_t</li>
                    <ul>
                        <li>C++ only guarantees that integer variables will have a minimum size -- but they could be larger, depending on the target system.</li>
                        <li>When dealing with types that have uncertain ranges, it is possible that a program might work on one architecture but no on another due to
                            difference in the range that they support.
                        </li>
                        <li>To help with cross-platform portability, C99 defined a set of <strong>fixed-width integers</strong> (in the stdint.h header) that are guaranteed to have the same size on any architecture.</li>
                        <li><strong>Warning: </strong>Using fixed-width integers doesn't guarantee faster processing, it may be slower, it's depending on the architectures.</li>
                        <li><strong>Warning: </strong>Fixed-width integers should be avoided, as they may not be defined on all target architectures.</li>
                    </ul>
                <li>Fast and least integers</li>
                    <ul>
                        <li>The <strong>fast type</strong> (std::int_fast#_t) provides the fastest signed integer type with a width of at least # bits (where # = 8, 16, 32, or 64).</li>
                        <li>The <strong>least type</strong> (std::int_least#_t) provides the smallest signed integer type with a width of at least # bits (where # = 8, 16, 32, or 64).</li>
                        <pre style="margin: 0px">
                            <code>
    #include &lt;cstdint>
    #inlcude &lt;iostream>
    
    int main() &#123;
        std::cout &lt;&lt; "fast 8: " &lt;&lt; sizeof(std::int_fast8_t) * 8 &lt;&lt; " bits\n";
        std::cout &lt;&lt; "fast 16: " &lt;&lt; sizeof(std::int_fast16_t) * 8 &lt;&lt; " bits\n";
        std::cout &lt;&lt; "fast 32: " &lt;&lt; sizeof(std::int_fast32_t) * 8 &lt;&lt; " bits\n";
        std::cout &lt;&lt; "least 8: " &lt;&lt; sizeof(std::int_least8_t) * 8 &lt;&lt; " bits\n";
        std::cout &lt;&lt; "least 16: " &lt;&lt; sizeof(std::int_least16_t) * 8 &lt;&lt; " bits\n";
        std::cout &lt;&lt; "least 32: " &lt;&lt; sizeof(std::int_least32_t) * 8 &lt;&lt; " bits\n\n";
        return 0
    }
                            </code>
                        </pre>
                        <li>These fast and least types are guaranteed to be defined, and are safe to use.</li>
                        <li>Best practice: Favor the std::int_fast#_t and std::int_least#_t integers when you need an integer guaranteed to be at least a certain minimum size.</li>
                    </ul>
                    <li><strong>Warning: </strong>std::int8_t and std::uint8_t may behave like chars instead of integers</li>
                        <ul>
                            <li>For example, for the case below, most systems will print 'A' and only some systems may print 65.</li>
                            <pre style="margin: 0px">
                                <code>
    std::int8_t myint&#123;65};
    std::cout &lt;&lt; myint;                                
                                </code>
                            </pre>
                            <li><strong>Warning: </strong>Avoid the 8-bit fixed-width integer types. If you do use them, note that they are often treated like chars.</li>
                        </ul>
                    <li>Integer best practices</li>
                        <ul>
                            <li>Use int when the size of the integer doesn’t matter (numbers always fit within the range of -65535 to 65535)</li>           
                            <li>For guaranteed size and better performance, use std::int_fast#_t.</li>
                            <li>For guaranteed size and better memory conservation, use std::int_least#_t.</li>
                            <li>Avoid unsigned types unless really needed.</li>
                            <li>Avoid 8-bit fixed-width integer types.</li>
                            <li>Avoid compiler-specific fixed-width integers, for example, Visual Studio defines __int8, __int16, etc</li>
                        </ul>
            </ul>
            <mat-divider></mat-divider>
        </div> 
    </div>
    <div (click)="scrollTo('contentList')" class="floatingIconDiv">
        <fa-icon  [icon]="faArrowAltCircleUp" size="2x"></fa-icon>
    </div>
</div>