<div class="flexContainer" id="container">
    <div id="contentList">
        <mat-accordion displayMode="flat" style="padding-left: 5px; padding-right: 5px;">
            <mat-expansion-panel style="margin-top: 5px;">
                <mat-expansion-panel-header>
                    <mat-panel-title>
                        C++
                    </mat-panel-title>
                </mat-expansion-panel-header>
                <button mat-button class="listItem" (click)="scrollTo('chapter1')">Chapter 1: C++ Basics</button>
                <button mat-button class="listItem" (click)="scrollTo('chapter2')">Chapter 2: Functions and Files</button>
                <button mat-button class="listItem" (click)="scrollTo('chapter3')">Chapter 3: Debugging C++ Programs</button>
                <button mat-button class="listItem" (click)="scrollTo('chapter4')">Chapter 4: Fundamental Data Types</button>
                <button mat-button class="listItem" (click)="scrollTo('chapter5')">Chapter 5: Operators</button>
                <button mat-button class="listItem" (click)="scrollTo('chapterO')">Chapter O: Bit Manipulation</button>
                <button mat-button class="listItem" (click)="scrollTo('chapter6')">Chapter 6: Scope, Duration, and Linkage</button>
            </mat-expansion-panel>
        </mat-accordion>
    </div>
    <div fxLayout="column" fxLayout="column">
        <div>
            <h1>C++</h1>
            <h2>Introduction</h2>
            <p>The following are mainly the notes summarized from <a href="https://www.learncpp.com/" target="_blank" rel="noopener noreferrer">learncpp.com</a>.</p>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter1">
            <h2>Chapter 1: C++ Basics</h2>
            <ul>
                <li>Every C++ program must have a special function named main (all lower case letters).</li>
                <li>In C++, an <strong>object</strong> is a region of storage (usually memory) that has a value and other associated properties.</li>
                <li>A named object is called a <strong>variable</strong>, and the name of the object is called an <strong>identifier</strong></li>
                <li>In C++, the type of a variable must be known at compile-time (when the program is compiled), and that type can not be changed without recompiling the program.</li>
                <li>4 ways to initialize variables in C++</li>
                    <ul>
                        <li>int a; // Uninitalizaed (ERROR)</li>
                        <li>int b = 5; // Copy Initialization (NOT RECOMMENDED)</li>
                        <li>int c(6); // Direct Initialization (NOT RECOMMENDED)</li>
                        <li>int d&#123;7}; // List Initilization or Uniform Initilization (RECOMMENDED)</li>
                    </ul>
                <li>List initialization has the added benefit of disallowing “narrowing” conversions, whereas copy initialization and direct initialization only prompt warning.</li>
                <ul>
                    <li>int a = 3.5; // will have warning</li>
                    <li>int b(3.5); // will have warning</li>
                    <li>int c&#123;3.5}; // will have error</li>
                </ul>
                <li>Initializing variables with empty braces &#123;} will initialize the variable to either zero or empty</li>
                <li>Using '\n' is typically preferred as compared to std::endl because the later has an extra unnecessary action of flushing the output.</li>
                <li>Using this statement as example: int x&#123;2 + 3}</li>
                    <ul>
                        <li>'2' and '3' are <strong>literal</strong></li>
                        <li>'+' is <strong>operator</strong></li>
                        <li>'2 + 3' is <strong>expression</strong></li>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter2">
            <h2>Chapter 2: Functions and Files</h2>
            <ul>
                <li>Nested functions are not supported in C++</li>
                <li>Your main function should return 0 if the program ran normally.</li>
                <li>The C++ standard only defines the meaning of 3 status codes:
                    <ul>
                        <li>0 >> means the program executed successfully</li>
                        <li>EXIT_SUCCESS >> means the program executed successfully</li>
                        <li>EXIT_FAILURE >> means the program did not executed successfully</li>
                    </ul>
                </li>
                <li>Failure to return a value from a function with a non-void return type (other than main) will result in undefined behavior.</li>
                <li>A <strong>function parameter</strong> is a variable used in a function.</li>
                <li>An <strong>argument</strong> is a value that is passed from the caller to the function</li>
                <li>The C++ specification does not define whether function calls evaluate arguments left to right or right to left. 
                    Take care not to make function calls where argument order matters.</li>
                <li>Always do a <strong>forward declaration</strong> to tell the compiler about the existence of an identifier (including function) before actually defining the identifier.</li>
                <li>Example:</li>
                <pre>
                    <code>
    #include &lt;iostream>
    int getValueFromUser(); // forward declaration
    int multiplyBy2(int num); // forward declaration

    int main()
    &#123;
        int num&#123; getValueFromUser() }; // initialize num with the return value of getValueFromUser()
        std::cout &lt;&lt; num &lt;&lt; " doubled is: " &lt;&lt; multiplyBy2(num) &lt;&lt; '\n'; // num here is called argument
        return 0;
    }

    int getValueFromUser()
    &#123;
        std::cout &lt;&lt; "Enter an integer: ";
        int input&#123;};
        std::cin >> input;

        return input;
    }

    // num here is called parameter
    int multiplyBy2(int num) &#123;
        return num * 2;
    }
                    </code>
                </pre>
                <li>Declaration vs Definition</li>
                    <ul>
                        <li>A <strong>declaration</strong> is a statement that tells the compiler about the existence of an identifier
                            and its type information.</li>
                        <li>A <strong>definition</strong> actually implements (for functions or types) or instantiates (for variables) the identifier.</li>
                    </ul>
                <li>Namespace</li>
                    <ul>
                        <li>A <strong>namespace</strong> is a declarative region that provides a scope (called namespace scope) to the identifiers (the names of types, functions, variables, etc) inside it</li>
                        <li>In C++, any name that is not defined inside a class, function, or a namespace is considered to be part of <strong>global namespace</strong> (sometimes called <strong>global scope</strong>)</li>
                        <li>If there are identical names within an explicit namespace or global namespace, <strong>naming collision</strong> error will be produced.</li>
                        <li>A common namespace that we always use is <span style="font-style: italic;">std</span>, which we always use the :: symbol (scope resolution operator) to link 
                            std namespace and the identifiers within it.</li>
                            <ul>
                                <li>std::cout &lt;&lt; "Hello world!"; // example</li>
                            </ul>
                        <li>Another way to access identifiers inside a namespace is to use a <span style="font-style: italic;">using directive</span> statement (for example: <span style="font-style: italic;">using namespace std;</span>).
                        However, avoid using this as it violates the reason why namespaces were added in the first place.</li>
                    </ul>
                <li>Translation & Preprocessor</li>
                    <ul>
                        <li>Prior to compilation, the code file goes through a phase known as <strong>translation</strong>.</li>
                        <li>The translation phases involves the <strong>preprocessor</strong>, which can be best thought of as a separate program that manipulates the text in each code file.</li>
                        <li><strong>Preprocessor directives</strong> are instructions that start with a # symbol and end with a newline (NOT a semicolon).</li>
                        <li>Directives are resolved before compilation, from top to bottom on a file-by-file basis, therefore the output of the preprocessor contains no directives at all.</li>
                        <li>#include</li>
                            <ul>
                                <li>When you #include a file, the preprocessor replaces the #include directive with the contents of the included file.</li>
                            </ul>
                        <li>#define</li>
                            <ul>
                                <li>The #define directive can be used to create a macro.</li>
                            </ul>
                        <li>Macro</li>
                            <ul>
                                <li>In C++, a <strong>macro</strong> is a rule that defines how input text is converted into replacement output text.</li>
                                <li>Object-like macros with substitution text</li>
                                    <ul>
                                        <li>The preprocessor will replace any futher occurence of the identifier (normally in all capital letters and use underscores to represent spaces)
                                             by the <span style="font-style: italic;">substitution text</span>.</li>
                                        <li>The text substitution action will not affect other preprocessor directives.</li>
                                        <pre>
                                            <code>
    #include &lt;iostream>
    #define MY_NAME "ALEX"
    int main() &#123;
        std::cout &lt;&lt; "My name is: " &lt;&lt; MY_NAME;
    }
                                            </code>
                                        </pre>
                                    </ul>
                                <li>Object-like macros without substitution text</li>
                                    <ul>
                                        <li>This is useless for doing text substitution but it is used for conditional compilation.</li>
                                        <li>#define USE_YEN // example</li>
                                    </ul>
                            </ul>
                        <li>Conditional Compilation</li>
                            <ul>
                                <li>The commonly used conditional compilation directives are:</li>
                                    <ul>
                                        <li>#ifdef</li>
                                        <li>#ifndef</li>
                                        <li>#endif</li>
                                        <li>#if 0</li>
                                    </ul>
                                <li>Example:</li>
                                    <pre>
                                        <code>
    #include &lt;iostream>

    #define PRINT_JOE
        
    int main() &#123;
        #ifdef PRINT_JOE
            std::cout &lt;&lt; "Joe is defined\n"; // if PRINT_JOE is defined, compile this code
        #endif
            
        #ifndef PRINT_BOB
            std::cout &lt;&lt; "Bob is not defined\n"; // if PRINT_BOB is defined, compile this code
        #endif

        #if 0 // Don't compile anything starting here
            std::cout &lt;&lt; "Test 123\n";
        #endif // until this point
            
        return 0;
    }
                                        </code>
                                    </pre>
                                <li><span style="background-color: whitesmoke; font-style: italic;">#ifdef PRINT_BOB</span> can also be written as <span style="background-color: whitesmoke; font-style: italic;">#if defined(PRINT_BOB)</span></li>
                            </ul>
                        <li>Directives defined in one code file do not have impact on other code files in the same project. In other words, they are not in global scope.</li>
                    </ul>
                <li>Header files</li>
                    <ul>
                        <li><strong>Best practicce</strong>: Use a .h suffix when naming your header files.</li>
                        <li><strong>Best practicce</strong>: When including a header file from the standard library, use the version without the .h extension if it exists.</li>
                        <li><strong>Best practicce</strong>: DO NOT put any function definition in header files.</li>
                        <li><strong>Best practicce</strong>: If a header file is paired with a code file (e.g. add.h with add.cpp), they should both have the same base name (add).</li>
                        <li><strong>Best practicce</strong>: Code files should #include their paired header file (if one exists).</li>
                        <pre>
                            <code>
    // IN add.h
    int add (int x, int y)

    // IN add.cpp
    #include "add.h"
    int add (int x, int y) &#123;
        return x + y;
    }

    // IN main.cpp
    #include "add.h"         // double quotes
    #include &lt;iostream>      // angled quotes, and without .h extension
    
    int main()
    &#123;
        std::cout &lt;&lt; "The sum of 3 and 4 is " &lt;&lt; add(3, 4) &lt;&lt; '\n';
        return 0;
    }
                            </code>
                        </pre>
                        <li>Angled brackets vs double quotes</li>
                            <ul>
                                <li>When we use angled brackets, we’re telling the preprocessor that this is a header file we didn’t write ourselves.</li>
                                <ul>
                                    <li>The compiler will search for the header only in the directories specified by the <span style="background-color: whitesmoke; font-style: italic;">include directories</span>.</li>
                                    <li>The <span style="background-color: whitesmoke; font-style: italic;">include directories</span> are configured as part of your project/IDE settings/compiler settings, 
                                        and typically default to the directories containing the header files that come with your compiler and/or OS.</li>
                                    <li>The compiler WILL NOT search for the header file in your project’s source code directory.</li>
                                </ul>
                                <li>When we use double-quotes, we’re telling the preprocessor that this is a header file that we wrote.</li>
                                <ul>
                                    <li>The compiler will first search for the header file in the current directory.</li>
                                    <li>If it can’t find a matching header there, it WILL then search the <span style="background-color: whitesmoke; font-style: italic;">include directories</span>.</li>
                                </ul>
                            </ul>
                        <li>Why doesn’t iostream have a .h extension?</li>
                            <ul>
                                <li>iostream.h and iostream are two different header files.</li>
                                <li>iostream.h was initally used and the iostream is a new header file with std namespace implementation</li>
                                <li>iostream.h is for the support of older programs</li>
                                <li>Hence, when including a header file from the standard library, use the version without the .h extension if it exists.</li>
                            </ul>
                        <li><strong>Best practicce</strong>: Each file should explicitly #include all the header files needed for its compilation. DO NOT rely on headers included in other some other header files.</li>
                        <li><strong>Best practicce</strong>: Order your #includes as follows and sort each section alphabetically:
                            <ul>
                                <li>your own user-defined headers</li>
                                <li>3rd party library headers</li>
                                <li>standard library headers</li>
                            </ul>
                        </li>
                    </ul>
                <li>Header Guards</li>
                    <ul>
                        <li>As header files may include other headers, it is possible that we include a same header multiple times, and this will lead to compilation error due to duplicate definition.</li>
                        <li>Hence, we need <strong>Header Guards</strong>, which are the conditional compilation directives.</li>
                        <li>Example:</li>
                            <pre>
                                <code>
    // IN add.h
    #ifndef ADD_H
    #define ADD_H
    int add(int x, int y);
    ##endif

    // IN add.cpp
    #include "add.h"
    int add(int x, int y) &#123;
        return x + y;
    }

    // IN main.cpp
    #include "add.h"
    #include &lt;iostream>
    
    int main() &#123;
        std::cout &lt;&lt; "1 + 2 = " &lt;&lt; add(1,2) &lt;&lt; '\n';
    
        return 0;
    }
                                </code>
                            </pre>
                        <li>#pragma once</li>
                            <ul>
                                <li><span style="background-color: whitesmoke; font-style: italic;">#pragma once</span> is an alternative type of header guards</li>
                                <li>However, <span style="background-color: whitesmoke; font-style: italic;">#pragma once</span> is NOT an official part of the C++ language, and not all compilers support it (although most modern compilers do).</li>
                                <li><strong>Best practicce</strong>: For compatibility purposes, stick to traditional header guards.</li>
                            </ul>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter3">
            <h2>Chapter 3: Debugging C++ Programs</h2>
            <p>Debugging is general skill and debugging skill should be polished through hands-on. Hence, not many notes for this chapter.</p>
            <ul>
                <li>A <strong>syntax error</strong> occurs when you write a statement that is not valid according to the grammar of the C++ language.</li>
                <li>A <strong>semantic error</strong> occurs when a statement is syntactically valid, but does not do what the programmer intended.</li>
            </ul>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter4">
            <h2>Chapter 4: Fundamental Data Types</h2>
            <ul>
                <li>Bits, bytes, and memory addressing</li>
                    <ul>
                        <li>The smallest unit of memory is a binary digit (also called a bit)</li>
                        <li>Memory is organized into sequential units called memory addresses</li>
                        <li>Each memory address holds 1 byte of data (1 byte = 8 sequential bits)</li>
                        <li>In C++, we typically work with “byte-sized” chunks of data.</li>
                    </ul>
                <li>_t suffix</li>
                    <ul>
                        <li>Many of the types defined in newer versions of C++ (e.g. std::nullptr_t) use a _t suffix.</li>
                        <li>This suffix means “type”, and it’s a common nomenclature applied to modern types.</li>
                    </ul>
                <li>Object sizes and the sizeof operator</li>
                    <ul>
                        <li>A single object may use 2, 4, 8, or even more consecutive memory addresses. </li>
                        <li>The amount of memory that an object uses is based on its data type.</li>
                        <li>The size of a given data type is dependent on the compiler and/or the computer architecture!</li>
                        <li>C++ only guarantees that each fundamental data types will have a minimum size:</li>
                            <table style="margin: 10px; overflow: auto; width: 100%;">
                                <tr class="trFlex">
                                    <th class="thQuarter">Category</th>
                                    <th class="thQuarter">Types</th>
                                    <th class="thQuarter">Minumum Size</th>
                                    <th class="thQuarter">Note</th>
                                </tr>
                                <tr class="trFlex">
                                    <td class="tdQuarter">Integral (Boolean)</td>
                                    <td class="tdQuarter">bool</td>
                                    <td class="tdQuarter">1 byte</td>
                                    <td class="tdQuarter"></td>
                                </tr>
                                <tr class="trFlex">
                                    <td class="tdQuarter">
                                        Integral (Character)
                                    </td>
                                    <td class="tdQuarter">
                                        <div>char</div>
                                        <div>wchar_t</div>
                                        <div>char8_t</div>
                                        <div>char16_t</div>
                                        <div>char32_t</div>
                                    </td>
                                    <td class="tdQuarter">
                                        <div>1 byte</div>
                                        <div>2 bytes</div>
                                        <div>1 byte</div>
                                        <div>2 bytes</div>
                                        <div>4 bytes</div>
                                    </td>
                                    <td class="tdQuarter">
                                        <div>Always 1 byte</div>
                                        <div>-</div>
                                        <div>-</div>
                                        <div>-</div>
                                        <div>-</div>
                                    </td>
                                </tr>
                                <tr class="trFlex">
                                    <td class="tdQuarter">Integral (Integer)</td>
                                    <td class="tdQuarter">
                                        <div>short</div>
                                        <div>int</div>
                                        <div>long</div>
                                        <div>long long</div>
                                    </td>
                                    <td class="tdQuarter">
                                        <div>2 bytes</div>
                                        <div>2 bytes</div>
                                        <div>4 bytes</div>
                                        <div>8 bytes</div>
                                    </td>
                                    <td class="tdQuarter"></td>
                                </tr>
                                <tr class="trFlex">
                                    <td class="tdQuarter">Floating Point</td>
                                    <td class="tdQuarter">
                                        <div>float</div>
                                        <div>double</div>
                                        <div>long double</div>
                                    </td>
                                    <td class="tdQuarter">
                                        <div>4 bytes</div>
                                        <div>8 bytes</div>
                                        <div>8 bytes</div>
                                    </td>
                                    <td class="tdQuarter"></td>
                                </tr>
                            </table>
                        <li><strong>Best practicce</strong>: For maximum compatibility, you shouldn’t assume that variables are larger than the specified minimum size.</li>
                        <li>The <strong>sizeof operator</strong> can be used to get the size in bytes of a date type or variable.</li>
                    </ul>
                <li>integers</li>
                    <ul>
                        <li>By default, integers are <strong>signed</strong>, which means the number’s sign is stored as part of the number (using a single bit called the sign bit).</li>
                        <li>An n-bit signed variable has a range of -(2<sup>n-1</sup>) to 2<sup>n-1</sup>-1.</li>
                        <li><strong>Integer overflow</strong> occurs when we try to store a value that is outside the range of the type.</li>
                        <li><strong>Warning: </strong>Signed integer overflow will result in undefined behavior.</li>
                        <li><strong>Warning: </strong>When doing division with two integers (called integer division), C++ always produces an integer result. 
                            Since integers can’t hold fractional values, any fractional portion is simply dropped (not rounded!).</li>
                    </ul>
                <li>unsigned integers</li>
                    <ul>
                        <li>An n-bit unsigned variable has a range of 0 to (2<sup>n</sup>)-1.</li>
                        <li>To define an unsigned integer, we use the unsigned keyword. By convention, this is placed before the type:</li>
                        <li>Unsigned integer overflow</li>
                            <ul>
                                <li>When unsigned integer overflow happens, the value can be determined and it is not undefined dehaviour.</li>
                                <li>The result of overflowed unsigned integer will be the overflow value divided by number of integers it can present, and only the remainder kept.</li>
                                <li>For example, 1-byte unsigned integer has a range of 0 - 255, if the unsigned integer overflows to 256, it will be 0,
                                    and if it overflows to 513, the value will be 1.
                                </li>
                                <li>In another way round, -negative numbers will be wrapped also. For example, setting a 1-byte unsigned integer to -1 will get 255.</li>
                                <li><strong>Warning: </strong>Avoid using unsigned numbers, except in specific cases or when unavoidable.</li>
                                <li><strong>Warning: </strong>If you do use unsigned numbers, avoid mixing signed and unsigned numbers where possible.</li>
                                <li>However, unsigned numbers are preferred when:</li>
                                    <ul>
                                        <li>dealing with bit manipulation</li>
                                        <li>array indexing</li>
                                        <li>dealing with embedded system for performance reasons</li>
                                    </ul>
                            </ul>
                    </ul>
                <li>Fixed-width integers and size_t</li>
                    <ul>
                        <li>C++ only guarantees that integer variables will have a minimum size -- but they could be larger, depending on the target system.</li>
                        <li>When dealing with types that have uncertain ranges, it is possible that a program might work on one architecture but no on another due to
                            difference in the range that they support.
                        </li>
                        <li>To help with cross-platform portability, C99 defined a set of <strong>fixed-width integers</strong> (in the stdint.h header) that are guaranteed to have the same size on any architecture.</li>
                        <li><strong>Warning: </strong>Using fixed-width integers doesn't guarantee faster processing, it may be slower, it's depending on the architectures.</li>
                        <li><strong>Warning: </strong>Fixed-width integers should be avoided, as they may not be defined on all target architectures.</li>
                    </ul>
                <li>Fast and least integers</li>
                    <ul>
                        <li>The <strong>fast type</strong> (std::int_fast#_t) provides the fastest signed integer type with a width of at least # bits (where # = 8, 16, 32, or 64).</li>
                        <li>The <strong>least type</strong> (std::int_least#_t) provides the smallest signed integer type with a width of at least # bits (where # = 8, 16, 32, or 64).</li>
                        <pre style="margin: 0px">
                            <code>
    #include &lt;cstdint>
    #inlcude &lt;iostream>
    
    int main() &#123;
        std::cout &lt;&lt; "fast 8: " &lt;&lt; sizeof(std::int_fast8_t) * 8 &lt;&lt; " bits\n";
        std::cout &lt;&lt; "fast 16: " &lt;&lt; sizeof(std::int_fast16_t) * 8 &lt;&lt; " bits\n";
        std::cout &lt;&lt; "fast 32: " &lt;&lt; sizeof(std::int_fast32_t) * 8 &lt;&lt; " bits\n";
        std::cout &lt;&lt; "least 8: " &lt;&lt; sizeof(std::int_least8_t) * 8 &lt;&lt; " bits\n";
        std::cout &lt;&lt; "least 16: " &lt;&lt; sizeof(std::int_least16_t) * 8 &lt;&lt; " bits\n";
        std::cout &lt;&lt; "least 32: " &lt;&lt; sizeof(std::int_least32_t) * 8 &lt;&lt; " bits\n\n";
        return 0
    }
                            </code>
                        </pre>
                        <li>These fast and least types are guaranteed to be defined, and are safe to use.</li>
                        <li><strong>Best practicce</strong>: Favor the std::int_fast#_t and std::int_least#_t integers when you need an integer guaranteed to be at least a certain minimum size.</li>
                    </ul>
                    <li><strong>Warning: </strong>std::int8_t and std::uint8_t may behave like chars instead of integers</li>
                        <ul>
                            <li>For example, for the case below, most systems will print 'A' and only some systems may print 65.</li>
                            <pre style="margin: 0px">
                                <code>
    std::int8_t myint&#123;65};
    std::cout &lt;&lt; myint;                                
                                </code>
                            </pre>
                            <li><strong>Warning: </strong>Avoid the 8-bit fixed-width integer types. If you do use them, note that they are often treated like chars.</li>
                        </ul>
                    <li><strong>Integer best practices</strong></li>
                        <ul>
                            <li>Use int when the size of the integer doesn’t matter (numbers always fit within the range of -65535 to 65535)</li>           
                            <li>For guaranteed size and better performance, use std::int_fast#_t.</li>
                            <li>For guaranteed size and better memory conservation, use std::int_least#_t.</li>
                            <li>Avoid unsigned types unless really needed.</li>
                            <li>Avoid 8-bit fixed-width integer types.</li>
                            <li>Avoid compiler-specific fixed-width integers, for example, Visual Studio defines __int8, __int16, etc</li>
                        </ul>
                    <li>Scientic Notation</li>
                        <ul>
                            <li>Numbers in scientific notation take the following form: significand x 10<sup>exponent</sup></li>
                            <li>For example: 1.2 x 10<sup>4</sup></li>
                            <li>In C++, the letter ‘e’ (or sometimes ‘E’) is used to represent the “times 10 to the power of” part of the equation</li>
                            <li>For example: 5.9736 x 10<sup>24</sup> could be written as 5.9736e24</li>
                            <li>The digits in the significand (the part before the ‘e’) are called the significant digits. </li>
                            <li>In standard scientfic notation, the trailing zeros after a decimal point represents the precision of a number. 
                                However, in C++, 88 and 88.000 are treated exactly the same by the compiler.</li>
                        </ul>
                    <li>Floating point numbers</li>
                        <ul>
                            <li>A floating point type variable is a variable that can hold a real number, such as 4320.0, -3.33, or 0.01226.</li>
                            <li>There are three different floating point data types: <strong>float</strong>, <strong>double</strong>, and <strong>long double</strong>.</li>
                            <li>Floating point data types are always signed</li>
                            <li>When using floating point literals, always include at least one decimal place (even if the decimal is 0). 
                                This helps the compiler understand that the number is a floating point number and not an integer.</li>
                            <li>By default, floating point literals default to type double. An f suffix is used to denote a literal of type float.</li>
                            <li>Best practice: Always make sure the type of your literals match the type of the variables they’re being assigned to or used to initialize. Otherwise an unnecessary conversion will result, possibly with a loss of precision.</li>
                            <pre>
                                <code>
    int v&#123; 5.0 }; // will have conversion error
    int w&#123; 5 }; 
    double x&#123; 5 }; // avoid using integer literals for floating point variables
    double y&#123; 5.0 }; // no suffix means double type by default
    float z&#123; 5.0f }; // f suffix means float type
    std::cout &lt;&lt; x &lt;&lt; "\n"; // output: 5
    std::cout &lt;&lt; y &lt;&lt; "\n"; // output: 5
    std::cout &lt;&lt; z &lt;&lt; "\n"; // output: 5
    std::cout &lt;&lt; 5.0 &lt;&lt; '\n'; // output: 5
    std::cout &lt;&lt; 6.7f &lt;&lt; '\n'; // output: 6.7
    std::cout &lt;&lt; 9876543.21 &lt;&lt; '\n'; // output: 9.87654e+06
                                </code>
                            </pre>
                            <li>When outputting floating point numbers, std::cout has a default precision of 6 -- that is, 
                                it assumes all floating point variables are only significant to 6 digits (the minimum precision of a float), and hence it will truncate anything after that.</li>
                            <li>We can override the default precision that std::cout shows by using an output manipulator function named <strong>std::setprecision()</strong></li>
                            <li>floating numbers precision:</li>
                                <ul>
                                    <li>Float values have between 6 and 9 digits of precision.</li>
                                    <li>Double values have between 15 and 18 digits of precision.</li>
                                    <li>Long double has a minimum precision of 15, 18, or 33 significant digits</li>
                                </ul>
                            <li><strong>Best practicce</strong>: Favor double over float unless space is at a premium, as the lack of precision in a float will often lead to inaccuracies.</li>
                            <pre>
                                <code>
    #include &lt;iomanip>
    #include &lt;iostream>

    int main() &#123;
        std::cout &lt;&lt; std::setprecision(16); // show 16 digits of precision
        std::cout &lt;&lt; 3.33333333333333333333333333333333333333f &lt;&lt; '\n'; // output: 3.333333253860474 (float has lower precision, hence more errors)
        std::cout &lt;&lt; 3.33333333333333333333333333333333333333 &lt;&lt; '\n'; // output: 3.333333333333333
        float f&#123; 123456789.0f };
        std::cout &lt;&lt; std::setprecision(9); // to show 9 digits in f
        std::cout &lt;&lt; f &lt;&lt; '\n';
        // output: 123456792 // float only has 7 digits of precision, hence it is only precise to 7 significant figures

        return 0;
    }
                                </code>
                            </pre>
                            <li><strong>Warning: </strong>Never assume your floating point numbers are exact.</li>
                            <pre>
                                <code>
    double d1&#123; 1.0 };
    std::cout &lt;&lt; d1 &lt;&lt; '\n'; // output: 1
    double d2&#123; 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1}; // should be equal to 1.0
    std::cout &lt;&lt; std::setprecision(17);
    std::cout &lt;&lt; d2 &lt;&lt; '\n'; // output: 0.99999999999999989
                                </code>
                            </pre>
                        </ul>
                <li>NaN & Inf</li>
                    <ul>
                        <li><strong>NaN</strong>, stands for “Not a Number”</li>
                        <li><strong>Inf</strong>, represents infinity, can be positive or negative</li>
                        <li>NaN and Inf are only available if the compiler uses a specific format (IEEE 754) for floating point numbers.</li>
                        <li>The following are results using Visual Studio 2019 on Windows</li>
                            <pre>
                                <code>
    double posinf &#123; 5.0 / zero }; // positive infinity
    std::cout &lt;&lt; posinf &lt;&lt; '\n'; // output: inf

    double neginf &#123; -5.0 / zero }; // negative infinity
    std::cout &lt;&lt; neginf &lt;&lt; '\n'; // output: -inf

    double nan &#123; zero / zero }; // not a number (mathematically invalid)
    std::cout &lt;&lt; nan &lt;&lt; '\n'; // output: -nan(ind)
                                </code>
                            </pre>
                        <li><strong>Best practicce</strong>: Avoid division by 0 altogether, even if your compiler supports it.</li>
                    </ul>
                <li>Boolean values</li>
                    <ul>
                        <li>Boolean variables can have only two possible values: true, and false.</li>
                        <li>To declare a Boolean variable, we use the keyword bool.</li>
                        <li>In C++, std::cout prints 0 for false, and 1 for true:</li>
                        <li>If you want std::cout to print “true” or “false” instead of 0 or 1, you can use std::boolalpha.</li>
                        <li>To make std::cin accept “false” and “true” as inputs, need to enable the std::boolalpha option as well.</li>
                        <pre>
                            <code>
    std::cout &lt;&lt; true &lt;&lt; '\n'; // output: 0
    std::cout &lt;&lt; false &lt;&lt; '\n'; // output: 1
    std::cout &lt;&lt; std::boolalpha; // enable cout std::boolalpha
    std::cout &lt;&lt; true &lt;&lt; '\n'; // output: true
    std::cout &lt;&lt; false &lt;&lt; '\n'; // output: false
    bool b&#123;}; // default initialize to false
    std::cout &lt;&lt; "Enter a boolean value: ";
    std::cin >> std::boolalpha; // enable cin std::boolalpha
    std::cin >> b; // input: 'true'
    std::cout &lt;&lt; b &lt;&lt; '\n'; // output: true 
                            </code>
                        </pre>
                    </ul>
                <li>Chars</li>
                    <ul>
                        <li>The <strong>char</strong> data type was designed to hold a character.</li>
                        <li>A character can be a single letter, number, symbol, or whitespace.</li>
                        <li>The char data type is an integral type, meaning the underlying value is stored as an integer.</li>
                        <li>The integer stored by a char variable are intepreted as an ASCII character.</li>
                        <li>Character literals are always placed between single quotes (e.g. ‘g’, ‘1’, ‘ ‘).</li>
                        <li>Key insight: Whenever you see C++ syntax (excluding the preprocessor) that makes use of angled brackets, 
                            the thing between the angled brackets will most likely be a type.
                            This is typically how C++ deals with concepts that need a parameterizable type.</li>
                        <li>Char variables can only hold 1 character, if you input more than one characters in std::cin, 
                            it will put the rest in input buffer.</li>
                        <li>Char is defined by C++ to always be 1 byte in size.</li>
                        <li>By default, a char may be signed or unsigned (though it’s usually signed).</li>
                        <li>Single Quotes vs Double Quotes</li>
                            <ul>
                                <li>Stand-alone chars are always put in single quotes</li>
                                <li>Text put between double quotes (e.g. “Hello, world!”) is called a <strong>string</strong></li>
                                <li><strong>Warning: </strong>Remember not use single quotes for string:</li>
                                    <pre>
                                        <code>
    std::int16_t x&#123; 6 };
    std::int16_t y&#123; 12 };
    std::cout &lt;&lt; 'x: ' &lt;&lt; x &lt;&lt; '\n'; // output: 78792006
    std::cout &lt;&lt; 'y: ' &lt;&lt; y &lt;&lt; '\n'; // output: 794473612
    std::cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; '\n'; // output: x: 6
    std::cout &lt;&lt; "y: " &lt;&lt; y &lt;&lt; '\n'; // output: y: 12
                                        </code>
                                    </pre>
                            </ul>
                        <li>wchar_t, char8_t, char16_t, and char32_t</li>
                            <ul>
                                <li>wchar_t should be avoided in almost all cases (except when interfacing with the Windows API). </li>
                                <li>char16_t and char32_t were added to C++11 to provide explicit support for 16-bit and 32-bit Unicode characters.</li>
                                <li>char8_t has been added in C++20.</li>
                                <li>You won’t need to use char8_t, char16_t, or char32_t unless you’re planning on making your program Unicode compatible.</li>
                            </ul>
                    </ul>
                <li>String</li>
                    <ul>
                        <li>In C++, strings aren’t a fundamental type. Hence, to use strings in C++, we first need to #include the &lt;string> header to bring in the declarations for std::string.</li>
                        <li><strong>Warning: </strong>Don't use std::cin to read strings, use std::getline instead.</li>
                        <li><strong>Best practicce</strong>: If using std::getline to read strings, use the <strong>std::ws</strong> input manipulator to ignore leading whitespace. For detailed reason, 
                        refer to <a href="https://www.learncpp.com/cpp-tutorial/an-introduction-to-stdstring/" target="_blank" rel="noopener noreferrer">this tutorial</a>.</li>
                        <pre>
                            <code>
    #include &lt;string>
    #include &lt;iostream>
    
    int main() &#123;
        std::cout &lt;&lt; "Now enter your name: ";
        std::string name&#123;};
        std::getline(std::cin >> std::ws, name); // note: added std::ws here
        std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; '\n';
        return 0;
    }
                            </code>
                        </pre>
                        <li>.length() can be used to get the length of a string</li>
                    </ul>
                <li>Literal constants</li>
                    <ul>
                        <li>Literal suffix can be used to change the type of a literal</li>
                        <pre>
                            <code>
    std::cout &lt;&lt; 5 &lt;&lt; "\n"; // 5 (no suffix) is type int (by default)
    std::cout &lt;&lt; 5u &lt;&lt; "\n"; // 5u is type unsigned int
    std::cout &lt;&lt; 5L &lt;&lt; "\n"; // 5L is type long
    std::cout &lt;&lt; 5.0 &lt;&lt; "\n"; // 5.0 (no suffix) is type double (by default)
    std::cout &lt;&lt; 5.0f &lt;&lt; "\n"; // 5.0f is type float
    std::cout &lt;&lt; 5.0L &lt;&lt; "\n"; // 5.0L is type logn double

    // String literals
    std::cout &lt;&lt; "Hello, world!"; // "Hello, world!" is a C-style string literal
    std::cout &lt;&lt; "Hello," " world!"; // C++ will concatenate sequential string literals
    
    // Scientific notation for floating point literals
    double pi &#123; 3.14159 }; // 3.14159 is a double literal in standard notation
    double avogadro &#123; 6.02e23 }; // 6.02 x 10^23 is a double literal in scientific notation

    // Octal and hexadecimal literals
    int a&#123; 12 } // 12 in decimal 
    int b&#123; 014 }; // 0 before the number means this is octal // equivalent to 12 in decimal 
    int c&#123; 0xC} // 0x before the number means this is hexadecimal // equivalent to 12 in decimal
                            </code>
                        </pre>
                        <li>C++14 binary literals and digit separators</li>
                            <ul>
                                <li>In C++14, we can assign binary literals by using the 0b prefix:</li>
                                <pre>
                                    <code>
    int bin&#123;};        // assume 32-bit ints
    bin = 0b1;        // assign binary 0000 0000 0000 0001 to the variable
    bin = 0b11;       // assign binary 0000 0000 0000 0011 to the variable
    bin = 0b1010;     // assign binary 0000 0000 0000 1010 to the variable
    bin = 0b1111'0000; // quotation mark (‘) can be used as a digit separator
    int bin2 &#123; 0b1011'0010 };  // quotation mark (‘) can be used as a digit separator
                                    </code>
                                </pre>
                            </ul>
                        <li>Printing decimal, octal, hexadecimal, and binary numbers</li>
                            <ul>
                                <li>By default, C++ prints values in decimal.</li>
                                <li>You need to use std::dec, std::oct, and std::hex to print the number in different bases.</li>
                                <pre>
                                    <code>
    int x &#123; 12 };
    std::cout &lt;&lt; x &lt;&lt; '\n'; // decimal (by default)
    std::cout &lt;&lt; std::hex &lt;&lt; x &lt;&lt; '\n'; // hexadecimal
    std::cout &lt;&lt; x &lt;&lt; '\n'; // now hexadecimal
    std::cout &lt;&lt; std::oct &lt;&lt; x &lt;&lt; '\n'; // octal
    std::cout &lt;&lt; std::dec &lt;&lt; x &lt;&lt; '\n'; // return to decimal
    std::cout &lt;&lt; x &lt;&lt; '\n'; // decimal
                                    </code>
                                </pre>
                                <li>To print in binary, we need to use std::bitset:</li>
                                    <pre>
                                        <code>
    #include &lt;bitset> // for std::bitset
    #include &lt;iostream>
    
    int main() &#123;
        // std::bitset&lt;8> means we want to store 8 bits
        std::bitset&lt;8> bin1&#123; 0b1100'0101 }; // binary literal for binary 1100 0101
        std::bitset&lt;8> bin2&#123; 0xC5 }; // hexadecimal literal for binary 1100 0101
        std::cout &lt;&lt; bin1 &lt;&lt; ' ' &lt;&lt; bin2 &lt;&lt; '\n'; // output: 11000101 11000101
        return 0;
    }
                                        </code>
                                    </pre>
                            </ul>
                    </ul>
                <li>Constants</li>
                    <ul>
                        <li>Runtime constants & Compile-time constants</li>
                            <pre>
                                <code>
    #include &lt;iostream>
    const int maxAge &#123;100} // compile-time constant
    constexpr int maxNameLength &#123; 30 }; // compile-time constant
    int main() &#123;
        constexpr double gravity &#123; 9.8 }; // compile-time constant
        std::cout &lt;&lt; "Enter your age: ";
        int age&#123;};
        std::cin >> age;
        const int usersAge &#123; age }; // runtime constant because the value isn't known until the program is run
        constexpr int myAge &#123; age }; // will have error because age is not known during compile-time
        return 0;
    }
                                </code>
                            </pre>
                        <li><strong>Best practicce</strong>: If the constant value is known before running the program, use <strong>constexpr</strong> to declare. Else, use <strong>const</strong>.</li>
                        <li><strong>Warning: </strong>Avoid using #define to create symbolic constants macros.</li>
                        <li><strong>Best practicce</strong>: Use constexpr variables to provide a name and context for your magic numbers.</li>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div> 
        <div id="chapter5">
            <h2>Chapter 5: Operators</h2>
            <ul>
                <li>Operator's precedence determines which operator to be evaluated first.</li>
                <li>Operator's associativity determines whether a operator is to be evaluated from left to right or right to left.</li>
                <li>Precedence level 1 is the highest precedence level, and level 17 is the lowest. Operators with a higher precedence level get evaluated first.</li>
                <li>The operators in C++ have different precedences and associativity, refer to <a href="https://www.learncpp.com/cpp-tutorial/operator-precedence-and-associativity/" target="_blank" rel="noopener noreferrer">this page</a> for detailed list of operators.</li>
                <li><strong>Best practicce</strong>: Use parentheses to make it clear how an expression should evaluate, even if they are technically unnecessary.</li>
                <li>To do exponents in C++, #include the &lt;cmath> header, and use the pow() function:</li>
                    <pre>
                        <code>
    #include &lt;cmath>

    double x&#123; std::pow(2.0, 5.0) }; // 2 to the 5th power
                        </code>
                    </pre>
                <li>Note that the parameters (and return value) of function pow() are of type double. Due to rounding errors in floating point numbers, the results of pow() may not be precise (even if you pass it integers or whole numbers).</li>
                <li>Hence, to do integer exponentiation, you should use your own function, however, please make sure that your integer exponentiation will not overflow the integral type:</li>
                    <pre>
                        <code>
    #include &lt;cstdint> // for std::int_fast64_t
    #include &lt;iostream>

    // note: exp must be non-negative
    std::int_fast64_t powInt(int base, int exp) &#123;
        std::int_fast64_t result&#123; 1 };
        while (exp)
        &#123;
            if (exp & 1)
                result *= base;
            exp >>= 1;
            base *= base;
        }

        return result;
    }

    int main() &#123;
        std::cout &lt;&lt; powInt(2, 4); // output: 16
        return 0;
    }
                        </code>
                    </pre>
                <li><strong>Warning: </strong>C++ does not define the order of evaluation for function arguments or operator operands. 
                    Hence, don’t use a variable that has a side effect applied to it more than once in a given statement. For example:</li>
                    <pre>
                        <code>
    int add(int x, int y) &#123;
        return x + y;
    }
    
    int main() &#123;
        int x&#123; 5 };
        int value = add(x, ++x); // is this 5 + 6, or 6 + 6?
        // It depends on what order your compiler evaluates the function arguments in
    
        std::cout &lt;&lt; value; // value could be 11 or 12, depending on how the above line evaluates!
        return 0;
    }  
                        </code>
                    </pre>
                <li><strong>Best practicce</strong>: Always parenthesize the conditional part of the <strong>conditional operator (?:)</strong>, and consider parenthesizing the whole thing as well.</li>
                    <ul>
                        <li>This is because the ?: operator has a very low precedence</li>
                        <li>For example: </li>
                        <pre>
                            <code>
    int a&#123; 4 };
    int b&#123; 2 };
    std::cout &lt;&lt; ((a > b) ? a : b) &lt;&lt; '\n'; // output: 4
    std::cout &lt;&lt; (a > b) ? a : b &lt;&lt; '\n'; // output: 1
                            </code>
                        </pre>
                        <li>The second std::cout prints 1 because it was evaluated as (std::cout &lt;&lt; (x > y)) ? x : y;</li>
                    </ul>
                <li>Conditional operator can be useful for initializing constant variables:</li>
                    <pre>
                        <code>
    constexpr bool inBigClassroom &#123; false };
    constexpr int classSize &#123; inBigClassroom ? 30 : 20 };
                        </code>
                    </pre>
                <li>If a high level of precision is required, comparing floating point values using any of the relational operators can be dangerous.</li>
                <li><strong>Warning: </strong>Avoid using operator== and operator!= with floating point operands, as the floating numbers might be slightly different due to rounding errors.</li>
                <li>For floating point comparison, you are recommended to read the <a href="https://www.learncpp.com/cpp-tutorial/relational-operators-and-floating-point-comparisons/" target="_blank" rel="noopener noreferrer">full tutorial and explanation</a>.</li>
                <li>Short circuit evaluation</li>
                    <ul>
                        <li>Examples of short circuit evaluation</li>
                            <pre>
                                <code>
    if (x == 1 && y ==2 ) &#123;
        // if x == 1 is false, y == 2 is not evaluated, short circuit evaluation happen
    }

    if (x > 0 || y > 2) &#123;
        // if x > 0 is true, y > 2 is not evaluated, short circuit evaluation happen
    }
                                </code>
                            </pre>
                        <li>Short circuit evaluation is good for optimization purposes, but it will has bad effects when happening on expressions with side effects, for example:</li>
                        <pre>
                            <code>
        if (x == 1 && ++y == 2) // if x == 1 is false, the ++y will not be executed
                            </code>
                        </pre>
                        <li>Hence, avoid using expressions with side effects in conjunction with binary logical operators.</li>
                    </ul>
                <li>De Morgan's Law</li>
                    <ul>
                        <li>!(x && y) is equivalent to !x || !y</li>
                        <li>!(x || y) is equivalent to !x && !y</li>
                    </ul>
                <li>Logical XOR</li>
                    <ul>
                        <li>C++ DOES NOT provide a logical XOR operator. </li>
                        <li>However, you can easily mimic logical XOR using the inequality operator (!=):</li>
                            <ul>
                                <li>if (a != b) ... // a XOR b, assuming a and b are Booleans</li>
                                <li>if (a != b != c != d) ... // a XOR b XOR c XOR d, assuming a, b, c, and d are Booleans</li>
                            </ul>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div>
        <div id="chapterO">
            <h2>Chapter O: Bit Manipulation</h2>
            <ul>
                <li>Bit position is counted from right to left, starting from zero.
                    For example, given a bit sequence 00000101, we can say that the bits in position 0 and 2 have value 1.</li>
                <li>std::bitset provides 4 key functions that are useful for doing bit manipulation: </li>
                    <ul>
                        <li>test() allows us to query whether a bit is a 0 or 1</li>
                        <li>set() allows us to turn a bit on (this will do nothing if the bit is already on)</li>
                        <li>reset() allows us to turn a bit off (this will do nothing if the bit is already off)</li>
                        <li>flip() allows us to flip a bit value from a 0 to a 1 or vice versa</li>
                    </ul>
                <li><strong>Best practice: </strong>Use unsigned integer or std::bitset for bit manipulation, avoid using signed integer.</li>
                    <pre>
                        <code>
    #include &lt;bitset>
    #include &lt;iostream>
    
    int main() &#123;
        // bitset functions
        std::bitset&lt;8> bits&#123; 0b0000'0101u }; // we need 8 bits, start with bit pattern 0000 0101
        bits.set(3); // set bit position 3 to 1 (now we have 0000 1101)
        bits.flip(4); // flip bit 4 (now we have 0001 1101)
        bits.reset(4); // set bit 4 back to 0 (now we have 0000 1101)
        std::cout &lt;&lt; "All the bits: " &lt;&lt; bits &lt;&lt; '\n';  // output: 0000 1101
        std::cout &lt;&lt; "Bit 3 has value: " &lt;&lt; bits.test(3) &lt;&lt; '\n'; // output: 1
        std::cout &lt;&lt; "Bit 4 has value: " &lt;&lt; bits.test(4) &lt;&lt; '\n'; // output: 0
        
        // Bitwise Operators
        std::bitset&lt;8> x&#123; 0b0000'0110u };
        std::bitset&lt;8> y&#123; 0b0001'0100u };
        std::cout &lt;&lt; x &lt;&lt; '\n';         // output: 00000110
        std::cout &lt;&lt; y &lt;&lt; '\n';         // output: 00010100
        std::cout &lt;&lt; (x &lt;&lt; 1) &lt;&lt; '\n';  // output: 00001100
        std::cout &lt;&lt; (y >> 2) &lt;&lt; '\n';  // output: 00000101
        std::cout &lt;&lt; (x | y) &lt;&lt; '\n';   // output: 00010110
        std::cout &lt;&lt; (x & y) &lt;&lt; '\n';   // output: 00000100
        std::cout &lt;&lt; (x ^ y) &lt;&lt; '\n';   // output: 00010010
        std::cout &lt;&lt; ~x &lt;&lt; '\n';        // output: 11111001
    
        return 0;
    }
                        </code>
                    </pre>
                <li>C++ also provides bitwise assignment operators. For example, you can write x >>= 2, instead of x = x >> 2</li>
                <li>Bit masks</li>
                    <ul>
                        <li>A bit mask is a predefined set of bits that is used to select which specific bits will be modified by subsequent operations.</li>
                            <pre>
                                <code>
    constexpr std::uint_fast8_t mask0&#123; 0b0000'0001 }; // represents bit 0
    constexpr std::uint_fast8_t mask1&#123; 0b0000'0010 }; // represents bit 1
    constexpr std::uint_fast8_t mask2&#123; 0b0000'0100 }; // represents bit 2
    constexpr std::uint_fast8_t mask3&#123; 0b0000'1000 }; // represents bit 3
    constexpr std::uint_fast8_t mask4&#123; 0b0001'0000 }; // represents bit 4
    constexpr std::uint_fast8_t mask5&#123; 0b0010'0000 }; // represents bit 5
    constexpr std::uint_fast8_t mask6&#123; 0b0100'0000 }; // represents bit 6
    constexpr std::uint_fast8_t mask7&#123; 0b1000'0000 }; // represents bit 7
    std::uint_fast8_t switches&#123; 0b0000'1010 }; // assuming each bit control 1 switch
    std::cout &lt;&lt; "switch 1 is " &lt;&lt; ((switches & mask1) ? "on\n" : "off\n"); // check switch1 status
    switches |= mask7; // turn on switch 7
    std::cout &lt;&lt; std::bitset&lt;8> &#123;switches} &lt;&lt; '\n'; // output: 10001010
    switches &= ~mask1; // turn off switch 1
    std::cout &lt;&lt; std::bitset&lt;8> &#123;switches} &lt;&lt; '\n'; // output: 10001000
    switches ^= mask2; // toggle switch 2
    std::cout &lt;&lt; std::bitset&lt;8> &#123;switches} &lt;&lt; '\n'; // output: 10001100
    switches |= (mask5 | mask6); // bit masks involving multiple bits
    std::cout &lt;&lt; std::bitset&lt;8> &#123;switches} &lt;&lt; '\n'; // output: 11101100
                                </code>
                            </pre>
                    </ul>
                <li>Signed numbers and two's complement</li>
                    <ul>
                        <li>Signed integers are typically stored using a method known as <strong>two’s complement</strong>.</li>
                        <li>In two’s complement, the leftmost (most significant) bit is used as the sign bit.</li>
                        <li>A 0 sign bit means the number is positive, and a 1 sign bit means the number is negative.</li>
                        <li>Positive signed numbers are represented in binary just like positive unsigned numbers</li>
                        <li>Negative signed numbers are represented in binary as the bitwise inverse of the positive number, plus 1.</li>
                        <li>Converting decimal to binary (two’s complement)</li>
                            <ul>
                                <li>For example: representing -5 in binary two's complement</li>
                                <li>5 is 0000 0101</li>
                                <li>Invert the bits: 1111 1010</li>
                                <li>Add 1 to the bits: 1111 1011 // final answer</li>
                            </ul>
                        <li>Converting binary (two's complement) to decimal</li>
                            <ul>
                                <li>For example: converting 1001 1110 from two’s complement into a decimal number</li>
                                <li>The signed bit value is 1, so cannot straight away convert to decimal.</li>
                                <li>Invert the bits: 0110 0001</li>
                                <li>Add 1 to the bits: 0110 0010</li>
                                <li>0110 0010 in decimal is 98, hence, the final answer is -98</li>
                            </ul>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div>
        <div id="chapter6">
            <h2>Chapter 6: Scope, Duration, and Linkage</h2>
            <ul>
                <li><strong>Best practice: </strong>Keep the nesting level of your functions to 3 or less.</li>
                <li>Defining your own namespaces</li>
                    <ul>
                        <li>C++ allows us to define our own <strong>user-defined namespaces</strong> via the <span style="font-style: italic;">namespace</span> keyword.</li>
                        <li>Namespace identifiers are typically non-capitalized.</li>
                        <li>With namespaces, naming collisions can be prevented:</li>
                            <mat-tab-group style="border: black; padding-left: 10px; padding-right: 10px; border: solid;" [animationDuration]=0 disableRipple="true">
                                <mat-tab label="foo.h">
                                    <pre>
                                        <code>
        // IN foo.h
        #ifndef FOO_H
        #define FOO_H
    
        namespace foo &#123;
            int doSomething(int x, int y);
        }
    
        #endif
                                        </code>
                                    </pre>
                                </mat-tab>
                                <mat-tab label="foo.cpp">
                                    <pre>
                                        <code>
        // IN foo.cpp
        #include "foo.h"
        namespace foo // define a namespace named foo
        &#123;
            // This doSomething() belongs to namespace foo
            int doSomething(int x, int y)
            &#123;
                return x + y;
            }
        }
                                        </code>
                                    </pre>
                                </mat-tab>
                                <mat-tab label="goo.h">
                                    <pre>
                                        <code>
        // IN goo.h
        #ifndef GOO_H
        #define GOO_H
    
        namespace goo &#123;
            int doSomething(int x, int y);
        }
    
        #endif
                                        </code>
                                    </pre>
                                </mat-tab>
                                <mat-tab label="goo.cpp">
                                    <pre>
                                        <code>
        // IN goo.cpp
        #include "goo.h"
        namespace goo // define a namespace named goo
        &#123;
            // This doSomething() belongs to namespace goo
            int doSomething(int x, int y)
            &#123;
                return x - y;
            }
        }
                                        </code>
                                    </pre>
                                </mat-tab>
                                <mat-tab label="chapter6.cpp">
                                    <pre>
                                        <code>
        // IN chapter6.cpp
        #include &lt;iostream>
        #include "foo.h"
        #include "goo.h"
        
        int main() &#123;
            std::cout &lt;&lt; goo::doSomething(4, 3) &lt;&lt; '\n'; // output: 7
            std::cout &lt;&lt; foo::doSomething(4, 3) &lt;&lt; '\n'; // output: 1
            return 0;
        }
                                        </code>
                                    </pre>
                                </mat-tab>
                              </mat-tab-group>
                        <li>Nested namespaces</li>
                            <ul>
                                <li>Namespaces can be nested inside other namespaces. For example:</li>
                                    <pre>
                                        <code>
    namespace foo &#123;
        namespace goo &#123;
            int add(int x, int y) &#123;
                return x + y;
            }
        }
    }                                            
                                        </code>
                                    </pre>
                            </ul>
                        <li>You also can create <strong>namespace alliases</strong>. For example:</li>
                            <pre>
                                <code>
                                    
int main() &#123;
    namespace active = foo::goo; // active now refers to foo::goo
    std::cout &lt;&lt; active::add(1, 2) &lt;&lt; '\n'; // This is really foo::goo::add()
    return 0;
}
                                </code>
                            </pre>
                    </ul>
                <li>Local variables</li>
                    <ul>
                        <li>Local variables have <strong>block scope</strong></li>
                        <li>Local variables have <strong>automatic storage duration</strong>, which means they are created at the point of definition and destroyed at the end of the block they are defined in.</li>
                        <li>Local variables have <strong>no linkage</strong>, which means that each declaration refers to a unique object.</li>
                        <li>Scope & Linkage</li>
                            <ul>
                                <li><strong>Scope</strong> defines where a single declaration can be seen and used</li>
                                <li><strong>Linkage</strong> defines whether multiple declarations refer to the same object or not.</li>
                            </ul>
                    </ul>
                <li>Global variables</li>
                    <ul>
                        <li><strong>Best practice: </strong>Consider using a “g” or “g_” prefix for global variables to help differentiate them from local variables.</li>
                        <li>Global variables have <strong>file scope</strong> (also called global scope). They are visible from the point of declaration until the end of the file in which they are declared.</li>
                        <li>Global variables are created when the program starts, and destroyed when it ends. This is called <strong>static duration</strong>.</li>
                        <li>Unlike local variables, which are uninitialized by default, static variables are zero-initialized by default, except const variables.</li>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div>
    </div>
    <div (click)="scrollTo('contentList')" class="floatingIconDiv">
        <fa-icon  [icon]="faArrowAltCircleUp" size="2x"></fa-icon>
    </div>
</div>