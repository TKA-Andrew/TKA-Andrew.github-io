<div class="flexContainer">
    <div fxLayout="column">
        <div>
            <h1>C++ Basics</h1>
            <h2>Introduction</h2>
            <p>The following are mainly the notes summarized from <a href="https://www.learncpp.com/" target="_blank" rel="noopener noreferrer">learncpp.com</a>.</p>
            <p>Some additional info are from Stack Overflow.</p>
            <p>Some uncommonly used notes are not included here.</p>
            <mat-divider></mat-divider>
        </div>

        <div>
            <h3>Basic Terminology</h3>
            <ul>
                <li>A named object is called a <strong>variable</strong>, and the name of the object is called an <strong>identifier</strong></li>
                <li>An <strong>argument</strong> is a value that is passed from the caller to the function</li>
                <li>Parameter vs Argument</li>
                    <ul>
                        <li>A <strong>function parameter</strong> is a variable used in a function.</li>
                        <li>An <strong>argument</strong> is a value that is passed from the caller to the function</li>
                    </ul>
                <li>Declaration vs Definition</li>
                    <ul>
                        <li>A <strong>declaration</strong> is a statement that tells the compiler about the existence of an identifier
                            and its type information.</li>
                        <li>A <strong>definition</strong> actually implements (for functions or types) or instantiates (for variables) the identifier.</li>
                    </ul>
                <li>Using this statement as example: int x&#123;2 + 3}</li>
                    <ul>
                        <li>'2' and '3' are <strong>literal</strong></li>
                        <li>'+' is <strong>operator</strong></li>
                        <li>'2 + 3' is <strong>expression</strong></li>
                    </ul>
                <li>Each memory address holds 1 byte of data (1 byte = 8 sequential bits)</li>
                
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Initilization</h3>
            <ul>
                <li>4 ways to initialize variables in C++:</li>
                    <ul>
                        <li>int a; // Uninitialized</li>
                        <li>int b = 5; // Copy Initialization (NOT RECOMMENDED)</li>
                        <li>int c(6); // Direct Initialization (NOT RECOMMENDED)</li>
                        <li>int d&#123;7}; // List Initilization or Uniform Initilization (RECOMMENDED)</li>
                    </ul>
                <li><b>List initialization</b> has the added benefit of disallowing “narrowing” conversions through error prompt.</li>
                    <ul>
                        <li>int a = 3.5; // will have warning</li>
                        <li>int b(3.5); // will have warning</li>
                        <li>int c&#123;3.5}; // will have error</li>
                    </ul>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Header Files: angled brackets &lt;> vs double quotes ""</h3>
            <ul>
                <li><b>Best practice</b>: Use a .h suffix for C/C++ compatible headers, use a .hpp suffix for C++ headers.</li>
                <li><b>Best practice</b>: When including a header file from the standard library, use the version without the .h extension if it exists (e.g. iostream). </li>
                <li>Angled brackets vs double quotes</li>
                    <ul>
                        <li>When we use <b>angled brackets</b>, we’re telling the preprocessor that this is a header file we didn’t write ourselves.</li>
                        <ul>
                            <li>The compiler will search for the header ONLY in the <span class="highlight-font">include directories</span>.</li>
                            <li>The <span class="highlight-font">include directories</span> are configured as part of your project/IDE settings/compiler settings, 
                                and typically default to the directories containing the header files that come with your compiler and/or OS.</li>
                            <li>The compiler WILL NOT search for the header file in your project’s source code directory.</li>
                        </ul>
                        <li>When we use <b>double-quotes</b>, we’re telling the preprocessor that this is a header file that we wrote.</li>
                        <ul>
                            <li>The compiler will first search for the header file in the current directory.</li>
                            <li>If it can’t find a matching header there, it WILL then search the <span class="highlight-font">include directories</span>.</li>
                        </ul>
                    </ul>
                <li><b>Best practice</b>: Each file should explicitly #include all the header files needed for its compilation. DO NOT rely on headers included in other some other header files.</li>
                <li><b>Best practice</b>: Order your #includes as follows and sort each section alphabetically:
                    <ul>
                        <li>your own user-defined headers</li>
                        <li>3rd party library headers</li>
                        <li>standard library headers</li>
                    </ul>
                </li>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Header-only libraries</h3>
            <ul>
                <li>Header-only libraries are libraries where the entire library is implemented using header files only (no .lib and .dll files will be provided)</li>
                <li>What are the advantages?</li>
                    <ul>
                        <li>Header-only library is the only choice when dealing with C++ templates, because the compiler needs to know the full definition of the templates in order to instantiate.</li>
                        <li>We do not need to build the library, and user doesn't need to compile our library before using it</li>
                    </ul>
                <li>What are the disadvantages?</li>
                    <ul>
                        <li>Most probably will have increased compilation time</li>
                        <li>if you change anything about the code in the header, then you’ll need to recompile every file that includes that header</li>
                        <li>Source code implementation is visible to user as it is written in the header file</li>
                    </ul>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Header Guards & #pragma once</h3>
            <ul>
                <li>As header files may include other headers, it is possible that we include a same header multiple times, and this will lead to compilation error due to duplicate definition.</li>
                <li>Hence, we need <strong>Header Guards</strong>, which are the conditional compilation directives.</li>
                <li>Example:</li>
                    <pre>
                        <code>
    // IN add.h
    #ifndef ADD_H
    #define ADD_H
    int add(int x, int y);
    ##endif
                        </code>
                    </pre>
                <li>According to <a href="https://www.learncpp.com/cpp-tutorial/header-guards/" target="_blank" rel="noopener noreferrer">learncpp.com</a></li>
                    <ul>
                        <li><span class="script-font">#pragma once</span> serves the same purpose as header guards, and has the added benefit of being shorter and less error-prone.</li>
                        <li>HOWEVER, <span class="script-font">#pragma once</span> is not an official part of the C++ language, and not all compilers support it (although most modern compilers do)</li>
                        <li>For compatibility purposes, it is RECOMMENDED sticking to traditional header guards.</li>
                    </ul>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Data Types: Best practices & Notes</h3>
            <ul>
                <li>The size of a given data type is dependent on the compiler and/or the computer architecture.</li>
                <li>C++ only guarantees that each fundamental data types will have a minimum size.</li>
                <li>Refer to this <a href="https://www.learncpp.com/cpp-tutorial/object-sizes-and-the-sizeof-operator/" target="_blank" rel="noopener noreferrer">tutorial</a>
                    for minimum size of different data types.</li>
                <li><strong>Integer best practices</strong></li>
                    <ul>
                        <li>Use int when the size of the integer doesn’t matter (numbers always fit within the range of -65535 to 65535)</li>           
                        <li>For guaranteed size and better performance, use std::int_fast#_t.</li>
                        <li>For guaranteed size and better memory conservation, use std::int_least#_t.</li>
                        <li>Avoid unsigned types unless really needed.</li>
                        <li>Avoid 8-bit fixed-width integer types.</li>
                        <li>Avoid compiler-specific fixed-width integers, for example, Visual Studio defines __int8, __int16, etc</li>
                    </ul>
                    <li><strong>Warning: </strong>When doing division with two integers (called integer division), C++ always produces an integer result. 
                        Since integers can’t hold fractional values, any fractional portion is simply dropped (not rounded!).</li>
                    <li><b>Best practice</b>: Always make sure the type of your literals match the type of the variables they’re being assigned to or used to initialize. Otherwise an unnecessary conversion will result, possibly with a loss of precision.</li>
                        <pre>
                            <code>
int v&#123; 5.0 }; // will have conversion error
double x&#123; 5 }; // avoid using integer literals for floating point variables
double y&#123; 5.0 }; // no suffix means double type by default
float z&#123; 5.0f }; // f suffix means float type
std::cout &lt;&lt; x &lt;&lt; "\n"; // output: 5
std::cout &lt;&lt; y &lt;&lt; "\n"; // output: 5
std::cout &lt;&lt; z &lt;&lt; "\n"; // output: 5
std::cout &lt;&lt; 5.0 &lt;&lt; '\n'; // output: 5
std::cout &lt;&lt; 6.7f &lt;&lt; '\n'; // output: 6.7
std::cout &lt;&lt; 9876543.21 &lt;&lt; '\n'; // output: 9.87654e+06
                            </code>
                        </pre>
                    <li><strong>Best practice</strong>: Favor double over float unless space is at a premium, as the lack of precision in a float will often lead to inaccuracies.</li>
                        <pre>
                            <code>
    #include &lt;iomanip> // for output manipulator std::setprecision()
    #include &lt;iostream>

    int main() &#123;
        std::cout &lt;&lt; std::setprecision(16); // show 16 digits of precision
        std::cout &lt;&lt; 3.33333333333333333333333333333333333333f &lt;&lt; '\n'; // output: 3.333333253860474 (float has lower precision, hence more errors)
        std::cout &lt;&lt; 3.33333333333333333333333333333333333333 &lt;&lt; '\n'; // output: 3.333333333333333
        float f&#123; 123456789.0f };
        std::cout &lt;&lt; std::setprecision(9); // to show 9 digits in f
        std::cout &lt;&lt; f &lt;&lt; '\n';
        // output: 123456792 // float only has 7 digits of precision, hence it is only precise to 7 significant figures

        return 0;
    }
                            </code>
                        </pre>
                    <li><strong>Warning: </strong>Never assume your floating point numbers are exact.</li>
                        <pre>
                            <code>
    double d1&#123; 1.0 };
    std::cout &lt;&lt; d1 &lt;&lt; '\n'; // output: 1
    double d2&#123; 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1}; // should be equal to 1.0
    std::cout &lt;&lt; std::setprecision(17);
    std::cout &lt;&lt; d2 &lt;&lt; '\n'; // output: 0.99999999999999989
                            </code>
                        </pre>
                    <li>In C++, std::cout prints 0 for false, and 1 for true:</li>
                    <li>If you want std::cout to print “true” or “false” instead of 0 or 1, you can use std::boolalpha.</li>
                    <li>Single Quotes vs Double Quotes</li>
                        <ul>
                            <li>Stand-alone chars are always put in single quotes</li>
                            <li>Text put between double quotes (e.g. “Hello, world!”) is called a <strong>string</strong></li>
                            <li><strong>Warning: </strong>Remember not use single quotes for string:</li>
                        </ul>
                    <li><strong>Best practice</strong>: If the constant value is known before running the program, use <strong>constexpr</strong> to declare. Else, use <strong>const</strong>.</li>
                    <li><strong>Warning: </strong>Avoid using #define to create symbolic constants macros.</li>
                    <li><strong>Best practice</strong>: Use constexpr variables to provide a name and context for your magic numbers.</li>
                    <li>De Morgan's Law</li>
                        <ul>
                            <li>!(x && y) is equivalent to !x || !y</li>
                            <li>!(x || y) is equivalent to !x && !y</li>
                        </ul>
                    <li>Logical XOR</li>
                        <ul>
                            <li>C++ DOES NOT provide a logical XOR operator. </li>
                            <li>However, you can easily mimic logical XOR using the inequality operator (!=):</li>
                                <ul>
                                    <li>if (a != b) ... // a XOR b, assuming a and b are Booleans</li>
                                    <li>if (a != b != c != d) ... // a XOR b XOR c XOR d, assuming a, b, c, and d are Booleans</li>
                                </ul>
                        </ul>
            </ul>
        </div>
        <mat-divider></mat-divider>
        
        <div>
            <h3>Operators</h3>
            <ul>
                <li>The operators in C++ have different precedences and associativity, refer to <a href="https://www.learncpp.com/cpp-tutorial/operator-precedence-and-associativity/" target="_blank" rel="noopener noreferrer">this page</a> for detailed list of operators.</li>
                <li>Note that the parameters (and return value) of function pow() are of type double. Due to rounding errors in floating point numbers, the results of pow() may not be precise (even if you pass it integers or whole numbers).</li>
                <li>Hence, for integer exponentiation, you may try to write your own exponential function base on this 
                    <a href="https://www.learncpp.com/cpp-tutorial/5-3-modulus-and-exponentiation/" target="_blank" rel="noopener noreferrer">tutorial</a>.</li>
                <li><strong>Warning: </strong>Avoid using operator== and operator!= with floating point operands, as the floating numbers might be slightly different due to rounding errors.</li>
                <li>For floating point comparison, you are recommended to read the <a href="https://www.learncpp.com/cpp-tutorial/relational-operators-and-floating-point-comparisons/" target="_blank" rel="noopener noreferrer">full tutorial and explanation</a>.</li>

            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>static & extern || Internal Linkage & External Linkage</h3>
            <ul>
                <li>Internal Linkage</li>
                <ul>
                    <li>An identifier with <strong>internal linkage</strong> can be seen and used within a single file, but it is not accessible from other files (that is, it is not exposed to the linker).</li>
                    <li>To make a non-constant global variable internal, we use the <strong>static</strong> keyword.</li>
                    <li>const and constexpr global variables have internal linkage by default, so the static keyword has no effect to them.</li>
                    <li>Functions are also default to external linkage, but can be set to internal linkage via the static keyword:</li>
                </ul>
                <li>External linkage</li>
                    <ul>
                        <li>An identifier with <strong>external linkage</strong> can be seen and used both from the file in which it is defined, and from other code files (via a forward declaration).</li>
                        <li>To make a global variable external (and thus accessible by other files), we can use the <strong>extern</strong> keyword to do so:</li>
                    </ul>
                <li>Example</li>
                    <pre>
                        <code>
    // IN abc.cpp
    extern const int g_w&#123; 3 }; // this extern gives g_w external linkage
    
    int minus(int x, int y) &#123;
        return (x - y);
    }
                        </code>
                    </pre>
                    <pre>
                        <code>
    // IN chapter6.cpp
    #include &lt;iostream>
    
    int g_s;                        // non-constant global variables have external linkage by default
    static int g_x;                 // the static keyword is used to make a non-constant global have internal linkage
    const int g_y&#123; 4 };            // const global variables have internal linkage by default
    constexpr int g_z&#123; 5 };        // constexpr global variables have internal linkage by default
    static int add(int x, int y);   // set this function to internal linkage
    
    // Forward Declarations
    int minus(int x, int y);    // functions are external linkage by default
    extern const int g_w;       // this extern is a forward declaration of a variable named g_w that is defined in the abc.cpp
    
    int add(int x, int y) &#123;
        return (x + y);
    }
    
    int main() &#123;
        std::cout &lt;&lt; add(g_y, g_z) &lt;&lt; '\n'; // output: 9
        std::cout &lt;&lt; minus(g_z, g_y) &lt;&lt; '\n'; // output: 1
        std::cout &lt;&lt; add(g_y, g_w) &lt;&lt; '\n'; // output: 7
        return 0;
    }
                        </code>
                    </pre>
            </ul>
        </div>
        <mat-divider></mat-divider>
        
        <div>
            <h3>Static Local Variables</h3>
            <ul>
                <li>Local variables have <b>automatic duration</b> by default, which means they are created at the point of definition, and destroyed when the block is exited.</li>
                <li>Using the <b>static</b> keyword on a local variable changes its duration from <b>automatic duration</b> to <b>static duration</b>.</li>
                <li>This means the variable is now <b>created at the start of the program</b>, and <b>destroyed at the end of the program</b> (just like a global variable).</li>
                <li><b>Static local variables are only initialized the first time the code is executed</b>, not on subsequent calls. So don't worry that they will be re-initialized multiple times. For example:</li>
                <pre>
                    <code>
    #include &lt;iostream>

    int generateID() &#123;
        static int s_itemID&#123; 0 }; // this only initialized at the first time
        return s_itemID++; // makes copy of s_itemID, increments the real s_itemID, then returns the value in the copy
    }
    
    int main() &#123;
        std::cout&lt;&lt;"OUTPUT:";
        for (int i&#123;0}; i&lt;10; i++) &#123;
            std::cout&lt;&lt;' '&lt;&lt;generateID();
        }
        // OUTPUT: 0 1 2 3 4 5 6 7 8 9
        return 0;
    }
                    </code>
                </pre>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>break vs return</h3>
            <ul>
                <li>A <strong>break statement</strong> terminates a switch or loop.</li>
                <li>A <strong>return statement</strong> terminates the entire function</li>
            </ul>
        </div>
        <mat-divider></mat-divider>
        
        <div>
            <h3>typedef & type aliases</h3>
            <ul>
                <li>Type aliases (preferred)</li>
                    <ul>
                        <li>In C++, <strong>using</strong> is a keyword that creates an alias for an existing data type.</li>
                        <li>For example: using distance_t = double; // define distance_t as an alias for type double</li>
                        <li>An alias does not actually define a new type -- it just introduces a new identifier for an existing type.</li>
                    </ul>
                <li>Typedef (not preferred)</li>
                    <ul>
                        <li><strong>typedef</strong> is a keyword with the same semantics as “using”, but reversed syntax.</li>
                        <li>For example: typedef double distance_t;</li>
                    </ul>
                <li><strong>Best practice: </strong>When creating aliased types, prefer the type alias syntax over the typedef syntax.</li>
                <li>Use case examples</li>
                    <ul>
                        <li>Using type aliases for platform independent coding</li>
                            <pre>
                                <code>
    #ifdef INT_2_BYTES
    using int8_t = char;
    using int16_t = int;
    using int32_t = long;
    #else
    using int8_t = char;
    using int16_t = short;
    using int32_t = int;
    #endif
                                </code>
                            </pre>
                        <li>Using type aliases to make complex types simple</li>
                            <pre>
                                <code>
    using pairlist_t = std::vector&lt;std::pair&lt;std::string, int> >; // make pairlist_t an alias for this crazy type
                                </code>
                            </pre>
                    </ul>
            </ul>
        </div>
        <mat-divider></mat-divider>
        
        <div>
            <h3>Function Overloading</h3>
            <ul>
                <li><strong>Function overloading</strong> allows us to create multiple functions with the same name, so long as each identically named function has different parameters</li>
                <li>For example:</li>
                    <pre>
                        <code>
    int add(int x, int y) // integer version
    &#123;
        return x + y;
    }

    double add(double x, double y) // floating point version
    &#123;
        return x + y;
    }
                            </code>
                    </pre>
                <li><strong>Best practice: </strong>Use function overloading to make your program simpler.</li>
                <li>Overloaded functions are differentiated by: </li>
                    <ul>
                        <li>Number of parameters</li>
                        <li>Type of parameters // excludes typedefs, type aliases</li>
                    </ul>
                <li>Take note that return type of a function is NOT considered for differentiation</li>
                <li>There is a detailed explanation about how function overload resolution happen in this <a href="https://www.learncpp.com/cpp-tutorial/function-overload-resolution-and-ambiguous-matches/" target="_blank" rel="noopener noreferrer">tutorial</a>
                but it will not be covered in this short note.</li>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>String</h3>
            <ul>
                
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Enum</h3>
            <ul>
                
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Struct</h3>
            <ul>
                
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Array</h3>
            <ul>
                
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Vector</h3>
            <ul>
                
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Pointer</h3>
            <ul>
                
            </ul>
        </div>
        <mat-divider></mat-divider>
        
        <div>
            <h3>New & Delete</h3>
            <ul>
                
            </ul>
        </div>
        <mat-divider></mat-divider>


    </div>
</div>