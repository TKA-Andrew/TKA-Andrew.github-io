<div class="flexContainer">
    <div fxLayout="column">
        <div>
            <h1>C++ Basics</h1>
            <h2>Introduction</h2>
            <ul>
                <li>The following are mainly the notes summarized from <a href="https://www.learncpp.com/" target="_blank" rel="noopener noreferrer">learncpp.com</a>.</li>
                <li>Some additional info are from Stack Overflow.</li>
                <li>Some uncommonly used notes are not included here.</li>
            </ul>
            <mat-divider></mat-divider>
        </div>

        <div>
            <h3>Basic Terminology</h3>
            <ul>
                <li>A named object is called a <strong>variable</strong>, and the name of the object is called an <strong>identifier</strong></li>
                <li>An <strong>argument</strong> is a value that is passed from the caller to the function</li>
                <li>Parameter vs Argument</li>
                    <ul>
                        <li>A <strong>function parameter</strong> is a variable used in a function.</li>
                        <li>An <strong>argument</strong> is a value that is passed from the caller to the function</li>
                    </ul>
                <li>Declaration vs Definition</li>
                    <ul>
                        <li>A <strong>declaration</strong> is a statement that tells the compiler about the existence of an identifier
                            and its type information.</li>
                        <li>A <strong>definition</strong> actually implements (for functions or types) or instantiates (for variables) the identifier.</li>
                    </ul>
                <li>Using this statement as example: int x&#123;2 + 3}</li>
                    <ul>
                        <li>'2' and '3' are <strong>literal</strong></li>
                        <li>'+' is <strong>operator</strong></li>
                        <li>'2 + 3' is <strong>expression</strong></li>
                    </ul>
                <li>Each memory address holds 1 byte of data (1 byte = 8 sequential bits)</li>
                
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Initilization</h3>
            <ul>
                <li>4 ways to initialize variables in C++:</li>
                    <ul>
                        <li>int a; // Uninitialized</li>
                        <li>int b = 5; // Copy Initialization (NOT RECOMMENDED)</li>
                        <li>int c(6); // Direct Initialization (NOT RECOMMENDED)</li>
                        <li>int d&#123;7}; // List Initilization or Uniform Initilization (RECOMMENDED)</li>
                    </ul>
                <li><b>List initialization</b> has the added benefit of disallowing “narrowing” conversions through error prompt.</li>
                    <ul>
                        <li>int a = 3.5; // will have warning</li>
                        <li>int b(3.5); // will have warning</li>
                        <li>int c&#123;3.5}; // will have error</li>
                    </ul>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Header Files: angled brackets &lt;> vs double quotes ""</h3>
            <ul>
                <li><b>Best practice</b>: Use a .h suffix for C/C++ compatible headers, use a .hpp suffix for C++ headers.</li>
                <li><b>Best practice</b>: When including a header file from the standard library, use the version without the .h extension if it exists (e.g. iostream). </li>
                <li>Angled brackets vs double quotes</li>
                    <ul>
                        <li>When we use <b>angled brackets</b>, we’re telling the preprocessor that this is a header file we didn’t write ourselves.</li>
                        <ul>
                            <li>The compiler will search for the header ONLY in the <span class="highlight-font">include directories</span>.</li>
                            <li>The <span class="highlight-font">include directories</span> are configured as part of your project/IDE settings/compiler settings, 
                                and typically default to the directories containing the header files that come with your compiler and/or OS.</li>
                            <li>The compiler WILL NOT search for the header file in your project’s source code directory.</li>
                        </ul>
                        <li>When we use <b>double-quotes</b>, we’re telling the preprocessor that this is a header file that we wrote.</li>
                        <ul>
                            <li>The compiler will first search for the header file in the current directory.</li>
                            <li>If it can’t find a matching header there, it WILL then search the <span class="highlight-font">include directories</span>.</li>
                        </ul>
                    </ul>
                <li><b>Best practice</b>: Each file should explicitly #include all the header files needed for its compilation. DO NOT rely on headers included in other some other header files.</li>
                <li><b>Best practice</b>: Order your #includes as follows and sort each section alphabetically:
                    <ul>
                        <li>your own user-defined headers</li>
                        <li>3rd party library headers</li>
                        <li>standard library headers</li>
                    </ul>
                </li>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Header-only libraries</h3>
            <ul>
                <li>Header-only libraries are libraries where the entire library is implemented using header files only (no .lib and .dll files will be provided)</li>
                <li>What are the advantages?</li>
                    <ul>
                        <li>Header-only library is the only choice when dealing with C++ templates, because the compiler needs to know the full definition of the templates in order to instantiate.</li>
                        <li>We do not need to build the library, and user doesn't need to compile our library before using it</li>
                    </ul>
                <li>What are the disadvantages?</li>
                    <ul>
                        <li>Most probably will have increased compilation time</li>
                        <li>if you change anything about the code in the header, then you’ll need to recompile every file that includes that header</li>
                        <li>Source code implementation is visible to user as it is written in the header file</li>
                    </ul>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Header Guards & #pragma once</h3>
            <ul>
                <li>As header files may include other headers, it is possible that we include a same header multiple times, and this will lead to compilation error due to duplicate definition.</li>
                <li>Hence, we need <strong>Header Guards</strong>, which are the conditional compilation directives.</li>
                <li>Example:</li>
                    <pre>
                        <code>
    // IN add.h
    #ifndef ADD_H
    #define ADD_H
    int add(int x, int y);
    ##endif
                        </code>
                    </pre>
                <li>According to <a href="https://www.learncpp.com/cpp-tutorial/header-guards/" target="_blank" rel="noopener noreferrer">learncpp.com</a></li>
                    <ul>
                        <li><span class="script-font">#pragma once</span> serves the same purpose as header guards, and has the added benefit of being shorter and less error-prone.</li>
                        <li>HOWEVER, <span class="script-font">#pragma once</span> is not an official part of the C++ language, and not all compilers support it (although most modern compilers do)</li>
                        <li>For compatibility purposes, it is RECOMMENDED sticking to traditional header guards.</li>
                    </ul>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Data Types: Best practices & Notes</h3>
            <ul>
                <li>The size of a given data type is dependent on the compiler and/or the computer architecture.</li>
                <li>C++ only guarantees that each fundamental data types will have a minimum size.</li>
                <li>Refer to this <a href="https://www.learncpp.com/cpp-tutorial/object-sizes-and-the-sizeof-operator/" target="_blank" rel="noopener noreferrer">tutorial</a>
                    for minimum size of different data types.</li>
                <li><strong>Integer best practices</strong></li>
                    <ul>
                        <li>Use int when the size of the integer doesn’t matter (numbers always fit within the range of -65535 to 65535)</li>           
                        <li>For guaranteed size and better performance, use std::int_fast#_t.</li>
                        <li>For guaranteed size and better memory conservation, use std::int_least#_t.</li>
                        <li>Avoid unsigned types unless really needed.</li>
                        <li>Avoid 8-bit fixed-width integer types.</li>
                        <li>Avoid compiler-specific fixed-width integers, for example, Visual Studio defines __int8, __int16, etc</li>
                    </ul>
                    <li><strong>Warning: </strong>When doing division with two integers (called integer division), C++ always produces an integer result. 
                        Since integers can’t hold fractional values, any fractional portion is simply dropped (not rounded!).</li>
                    <li><b>Best practice</b>: Always make sure the type of your literals match the type of the variables they’re being assigned to or used to initialize. Otherwise an unnecessary conversion will result, possibly with a loss of precision.</li>
                        <pre>
                            <code>
int v&#123; 5.0 }; // will have conversion error
double x&#123; 5 }; // avoid using integer literals for floating point variables
double y&#123; 5.0 }; // no suffix means double type by default
float z&#123; 5.0f }; // f suffix means float type
std::cout &lt;&lt; x &lt;&lt; "\n"; // output: 5
std::cout &lt;&lt; y &lt;&lt; "\n"; // output: 5
std::cout &lt;&lt; z &lt;&lt; "\n"; // output: 5
std::cout &lt;&lt; 5.0 &lt;&lt; '\n'; // output: 5
std::cout &lt;&lt; 6.7f &lt;&lt; '\n'; // output: 6.7
std::cout &lt;&lt; 9876543.21 &lt;&lt; '\n'; // output: 9.87654e+06
                            </code>
                        </pre>
                    <li><strong>Best practice</strong>: Favor double over float unless space is at a premium, as the lack of precision in a float will often lead to inaccuracies.</li>
                        <pre>
                            <code>
    #include &lt;iomanip> // for output manipulator std::setprecision()
    #include &lt;iostream>

    int main() &#123;
        std::cout &lt;&lt; std::setprecision(16); // show 16 digits of precision
        std::cout &lt;&lt; 3.33333333333333333333333333333333333333f &lt;&lt; '\n'; // output: 3.333333253860474 (float has lower precision, hence more errors)
        std::cout &lt;&lt; 3.33333333333333333333333333333333333333 &lt;&lt; '\n'; // output: 3.333333333333333
        float f&#123; 123456789.0f };
        std::cout &lt;&lt; std::setprecision(9); // to show 9 digits in f
        std::cout &lt;&lt; f &lt;&lt; '\n';
        // output: 123456792 // float only has 7 digits of precision, hence it is only precise to 7 significant figures

        return 0;
    }
                            </code>
                        </pre>
                    <li><strong>Warning: </strong>Never assume your floating point numbers are exact.</li>
                        <pre>
                            <code>
    double d1&#123; 1.0 };
    std::cout &lt;&lt; d1 &lt;&lt; '\n'; // output: 1
    double d2&#123; 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1}; // should be equal to 1.0
    std::cout &lt;&lt; std::setprecision(17);
    std::cout &lt;&lt; d2 &lt;&lt; '\n'; // output: 0.99999999999999989
                            </code>
                        </pre>
                    <li>In C++, std::cout prints 0 for false, and 1 for true:</li>
                    <li>If you want std::cout to print “true” or “false” instead of 0 or 1, you can use std::boolalpha.</li>
                    <li>Single Quotes vs Double Quotes</li>
                        <ul>
                            <li>Stand-alone chars are always put in single quotes</li>
                            <li>Text put between double quotes (e.g. “Hello, world!”) is called a <strong>string</strong></li>
                            <li><strong>Warning: </strong>Remember not use single quotes for string:</li>
                        </ul>
                    <li><strong>Best practice</strong>: If the constant value is known before running the program, use <strong>constexpr</strong> to declare. Else, use <strong>const</strong>.</li>
                    <li><strong>Warning: </strong>Avoid using #define to create symbolic constants macros.</li>
                    <li><strong>Best practice</strong>: Use constexpr variables to provide a name and context for your magic numbers.</li>
                    <li>De Morgan's Law</li>
                        <ul>
                            <li>!(x && y) is equivalent to !x || !y</li>
                            <li>!(x || y) is equivalent to !x && !y</li>
                        </ul>
                    <li>Logical XOR</li>
                        <ul>
                            <li>C++ DOES NOT provide a logical XOR operator. </li>
                            <li>However, you can easily mimic logical XOR using the inequality operator (!=):</li>
                                <ul>
                                    <li>if (a != b) ... // a XOR b, assuming a and b are Booleans</li>
                                    <li>if (a != b != c != d) ... // a XOR b XOR c XOR d, assuming a, b, c, and d are Booleans</li>
                                </ul>
                        </ul>
            </ul>
        </div>
        <mat-divider></mat-divider>
        
        <div>
            <h3>Operators</h3>
            <ul>
                <li>The operators in C++ have different precedences and associativity, refer to <a href="https://www.learncpp.com/cpp-tutorial/operator-precedence-and-associativity/" target="_blank" rel="noopener noreferrer">this page</a> for detailed list of operators.</li>
                <li>Note that the parameters (and return value) of function pow() are of type double. Due to rounding errors in floating point numbers, the results of pow() may not be precise (even if you pass it integers or whole numbers).</li>
                <li>Hence, for integer exponentiation, you may try to write your own exponential function base on this 
                    <a href="https://www.learncpp.com/cpp-tutorial/5-3-modulus-and-exponentiation/" target="_blank" rel="noopener noreferrer">tutorial</a>.</li>
                <li><strong>Warning: </strong>Avoid using operator== and operator!= with floating point operands, as the floating numbers might be slightly different due to rounding errors.</li>
                <li>For floating point comparison, you are recommended to read the <a href="https://www.learncpp.com/cpp-tutorial/relational-operators-and-floating-point-comparisons/" target="_blank" rel="noopener noreferrer">full tutorial and explanation</a>.</li>

            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>argc & *argv[] in C/C++</h3>
            <ul>
                <li><a href="https://www.geeksforgeeks.org/command-line-arguments-in-c-cpp/" target="_blank" rel="noopener noreferrer">Reference</a></li>
                <li>We can pass command-line arguments to C/C++ program by defining main() with 2 arguments: <span class="script-font">int main(int argc, char *argv[]) &#123;  }</span></li>
                <li><b>argc (ARGument Count)</b> is int and stores number of command-line arguments passed by the user <b>including</b> the name of the program.</li>
                <li><b>argv(ARGument Vector)</b> is array of character pointers listing all the arguments, and argv[0] will be name of the program.</li>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>static & extern || Internal Linkage & External Linkage</h3>
            <ul>
                <li>Internal Linkage</li>
                <ul>
                    <li>An identifier with <strong>internal linkage</strong> can be seen and used within a single file, but it is not accessible from other files (that is, it is not exposed to the linker).</li>
                    <li>To make a non-constant global variable internal, we use the <strong>static</strong> keyword.</li>
                    <li>const and constexpr global variables have internal linkage by default, so the static keyword has no effect to them.</li>
                    <li>Functions are also default to external linkage, but can be set to internal linkage via the static keyword:</li>
                </ul>
                <li>External linkage</li>
                    <ul>
                        <li>An identifier with <strong>external linkage</strong> can be seen and used both from the file in which it is defined, and from other code files (via a forward declaration).</li>
                        <li>To make a global variable external (and thus accessible by other files), we can use the <strong>extern</strong> keyword to do so:</li>
                    </ul>
                <li>Example</li>
                    <pre>
                        <code>
    // IN abc.cpp
    extern const int g_w&#123; 3 }; // this extern gives g_w external linkage
    
    int minus(int x, int y) &#123;
        return (x - y);
    }
                        </code>
                    </pre>
                    <pre>
                        <code>
    // IN chapter6.cpp
    #include &lt;iostream>
    
    int g_s;                        // non-constant global variables have external linkage by default
    static int g_x;                 // the static keyword is used to make a non-constant global have internal linkage
    const int g_y&#123; 4 };            // const global variables have internal linkage by default
    constexpr int g_z&#123; 5 };        // constexpr global variables have internal linkage by default
    static int add(int x, int y);   // set this function to internal linkage
    
    // Forward Declarations
    int minus(int x, int y);    // functions are external linkage by default
    extern const int g_w;       // this extern is a forward declaration of a variable named g_w that is defined in the abc.cpp
    
    int add(int x, int y) &#123;
        return (x + y);
    }
    
    int main() &#123;
        std::cout &lt;&lt; add(g_y, g_z) &lt;&lt; '\n'; // output: 9
        std::cout &lt;&lt; minus(g_z, g_y) &lt;&lt; '\n'; // output: 1
        std::cout &lt;&lt; add(g_y, g_w) &lt;&lt; '\n'; // output: 7
        return 0;
    }
                        </code>
                    </pre>
            </ul>
        </div>
        <mat-divider></mat-divider>
        
        <div>
            <h3>Static Local Variables</h3>
            <ul>
                <li>Local variables have <b>automatic duration</b> by default, which means they are created at the point of definition, and destroyed when the block is exited.</li>
                <li>Using the <b>static</b> keyword on a local variable changes its duration from <b>automatic duration</b> to <b>static duration</b>.</li>
                <li>This means the variable is now <b>created at the start of the program</b>, and <b>destroyed at the end of the program</b> (just like a global variable).</li>
                <li><b>Static local variables are only initialized the first time the code is executed</b>, not on subsequent calls. So don't worry that they will be re-initialized multiple times. For example:</li>
                <pre>
                    <code>
    #include &lt;iostream>

    int generateID() &#123;
        static int s_itemID&#123; 0 }; // this only initialized at the first time
        return s_itemID++; // makes copy of s_itemID, increments the real s_itemID, then returns the value in the copy
    }
    
    int main() &#123;
        std::cout&lt;&lt;"OUTPUT:";
        for (int i&#123;0}; i&lt;10; i++) &#123;
            std::cout&lt;&lt;' '&lt;&lt;generateID();
        }
        // OUTPUT: 0 1 2 3 4 5 6 7 8 9
        return 0;
    }
                    </code>
                </pre>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>break vs return</h3>
            <ul>
                <li>A <strong>break statement</strong> terminates a switch or loop.</li>
                <li>A <strong>return statement</strong> terminates the entire function</li>
            </ul>
        </div>
        <mat-divider></mat-divider>
        
        <div>
            <h3>typedef & type aliases</h3>
            <ul>
                <li>Type aliases (preferred)</li>
                    <ul>
                        <li>In C++, <strong>using</strong> is a keyword that creates an alias for an existing data type.</li>
                        <li>For example: using distance_t = double; // define distance_t as an alias for type double</li>
                        <li>An alias does not actually define a new type -- it just introduces a new identifier for an existing type.</li>
                    </ul>
                <li>Typedef (not preferred)</li>
                    <ul>
                        <li><strong>typedef</strong> is a keyword with the same semantics as “using”, but reversed syntax.</li>
                        <li>For example: typedef double distance_t;</li>
                    </ul>
                <li><strong>Best practice: </strong>When creating aliased types, prefer the type alias syntax over the typedef syntax.</li>
                <li>Use case examples</li>
                    <ul>
                        <li>Using type aliases for platform independent coding</li>
                            <pre>
                                <code>
    #ifdef INT_2_BYTES
    using int8_t = char;
    using int16_t = int;
    using int32_t = long;
    #else
    using int8_t = char;
    using int16_t = short;
    using int32_t = int;
    #endif
                                </code>
                            </pre>
                        <li>Using type aliases to make complex types simple</li>
                            <pre>
                                <code>
    using pairlist_t = std::vector&lt;std::pair&lt;std::string, int> >; // make pairlist_t an alias for this crazy type
                                </code>
                            </pre>
                    </ul>
            </ul>
        </div>
        <mat-divider></mat-divider>
        
        <div>
            <h3>Function Overloading</h3>
            <ul>
                <li><strong>Function overloading</strong> allows us to create multiple functions with the same name, so long as each identically named function has different parameters</li>
                <li>For example:</li>
                    <pre>
                        <code>
    int add(int x, int y) // integer version
    &#123;
        return x + y;
    }

    double add(double x, double y) // floating point version
    &#123;
        return x + y;
    }
                            </code>
                    </pre>
                <li><strong>Best practice: </strong>Use function overloading to make your program simpler.</li>
                <li>Overloaded functions are differentiated by: </li>
                    <ul>
                        <li>Number of parameters</li>
                        <li>Type of parameters // excludes typedefs, type aliases</li>
                    </ul>
                <li>Take note that return type of a function is NOT considered for differentiation</li>
                <li>There is a detailed explanation about how function overload resolution happen in this <a href="https://www.learncpp.com/cpp-tutorial/function-overload-resolution-and-ambiguous-matches/" target="_blank" rel="noopener noreferrer">tutorial</a>
                but it will not be covered in this short note.</li>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>String</h3>
            <ul>
                <li><strong>Warning: </strong>Don't use std::cin to read strings, use std::getline instead.</li>
                <li><strong>Best practice</strong>: If using std::getline to read strings, use the <strong>std::ws</strong> input manipulator to ignore leading whitespace. For detailed reason, 
                refer to <a href="https://www.learncpp.com/cpp-tutorial/an-introduction-to-stdstring/" target="_blank" rel="noopener noreferrer">this tutorial</a>.</li>
                <pre>
                    <code>
#include &lt;string>
#include &lt;iostream>

int main() &#123;
std::cout &lt;&lt; "Now enter your name: ";
std::string name&#123;};
std::getline(std::cin >> std::ws, name); // note: added std::ws here
std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; '\n';
return 0;
}
                    </code>
                </pre>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Enum</h3>
            <ul>
                <li>The following is an example of enum. By default, the enumerators are automatically assigned with integers starting from 0.</li>
                <pre>
                    <code>
    enum TrafficLightColor &#123;
        green,  // automatically assigned 0
        yellow, // automatically assigned 1
        red     // automatically assigned 2
    };
                    </code>
                </pre>
                <li>Enum is NOT type safe because the enumerators are not scoped. The following code will have redefinition error.</li>
                    <pre>
                        <code>
    std::string green = "green"; // let's say we declare a variable called "green"
    enum TrafficLightColor &#123;
        green,  // will have redefinition error
        yellow, 
        red    
    };
                    </code>
                </pre>
                <li>Hence, C++ 11 introduces <strong>enum class</strong> concept. To make an enum class, simply add the <strong>class</strong> keyword after the enum keyword.</li>
                    <pre>
                        <code>
    enum class TrafficLightColor &#123;
        green,
        yellow, 
        red    
    };
                        </code>
                    </pre>
                <li>Use case example of enum class</li>
                    <pre>
                        <code>
    #include &lt;iostream>
    #include &lt;string>
    
    enum class TrafficLightColor &#123;
        green,  // assigned 0
        yellow, // assigned 1
        red     // assigned 2
    };
    
    // instead of "int getTrafficLightStatus()"
    TrafficLightColor getTrafficLightStatus() &#123;
        return TrafficLightColor::green;
    }
    
    // instead of "void displayLight(int color)"
    void displayLight(TrafficLightColor color) &#123;
        if (color == TrafficLightColor::green) &#123;
            std::cout &lt;&lt; "green" &lt;&lt; '\n';
        }
        else if (color == TrafficLightColor::yellow) &#123;
            std::cout &lt;&lt; "yellow" &lt;&lt; '\n';
        }
        else if (color == TrafficLightColor::red) &#123;
            std::cout &lt;&lt; "red" &lt;&lt; '\n';
        }
    }

    int main() &#123;
        displayLight(getTrafficLightStatus());                       // output: "green"
        TrafficLightColor nextColor&#123; TrafficLightColor::yellow };    // variable declaration example
        std::cout &lt;&lt; static_cast&lt;int>(nextColor) &lt;&lt; '\n';            // output : 1
        displayLight(nextColor);                                     // output: "yellow"
        return 0;
    }
                        </code>
                    </pre>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Struct</h3>
            <ul>
                <li>A <strong>struct</strong> allows us to group variables of mixed types together into a single unit.</li>
                <li>The variables that are part of the struct are called <strong>members</strong>.</li>
                <li>An example of struct:</li>
                    <pre>
                        <code>
    struct Employee &#123;
        int id&#123;};
        int age&#123;};
        bool isPermanent&#123;};
        double wage&#123;};
    };

    Employee john; 
    john.id = 1234;
    john.age = 32;
    john.wage = 24;
    john.isPermanent = false;
    Employee jack&#123; 1122, 20, 18, false };
                        </code>
                    </pre>
                <li>We can set default value for the non-static struct members:</li>
                    <pre>
                        <code>
    struct Rectangle &#123;
        double length&#123; 1.0 };
        double width&#123; 1.0 };
    };
    Rectangle rectangleA&#123;}; // length = 1.0, width = 1.0
    Rectangle rectangleB&#123; 1.2 }; // length = 1.2, width = 1.0
                        </code>
                    </pre>
                <li>We can also pass the entire struct as argument to a function.</li>
                    <pre>
                        <code>
    void printInformation(Employee employee) &#123;
        std::cout &lt;&lt; "ID:   " &lt;&lt; employee.id &lt;&lt; '\n';
        std::cout &lt;&lt; "Age:  " &lt;&lt; employee.age &lt;&lt; '\n';
        std::cout &lt;&lt; "Wage: " &lt;&lt; employee.wage &lt;&lt; '\n';
    }
                        </code>
                    </pre>
                <li>A struct can be used as return type of function as well.</li>
                    <pre>
                        <code>
    struct Point3d &#123;
        double x&#123;};
        double y&#123;};
        double z&#123;};
    };

    Point3d getZeroPoint() &#123;
        // We can create a variable and return the variable.
        Point3d temp &#123; 0.0, 0.0, 0.0 };
        return temp;
    }
                        </code>
                    </pre>
                <li>Nested structs are also possible.</li>
                    <pre>
                        <code>
    struct Employee &#123;
        int id&#123;};
        int age&#123;};
        double wage&#123;};
    };

    struct Company &#123;
        Employee CEO&#123;}; // Employee is a struct within the Company struct
        int numberOfEmployees&#123;};
    };

    Company companyA&#123;&#123;0001, 52, 999}, 1000};
    std::cout &lt;&lt; companyA.CEO.wage &lt;&lt; '\n';
                        </code>
                    </pre>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Array</h3>
            <ul>
                <li>When declaring a fixed array, the length of the array must be a compile-time constant. For "array" with dynamic size, 
                    refer to C++ <a href="https://www.cplusplus.com/reference/vector/vector/" target="_blank" rel="noopener noreferrer">vector</a>.</li>
                <li>Examples of declaring arrays:</li>
                    <pre>
                        <code>
    int prime[5]&#123; 2, 3, 5, 7, 11 }; // use initializer list to initialize the fixed array
    int arrayA[10]&#123; 1, 2, 3}; // the rest of the elments are initilized to zero
    int arrayB[]&#123;0, 1, 2, 3, 4, 5} // let the initializer list set length of the array
                        </code>
                    </pre>
                <li>Passing arrays to functions</li>
                    <ul>
                        <li>When a normal variable is passed by value, C++ copies the value of the argument into the function parameter.
                            Hence, modifying the value of the parameter will not affect the original argument.</li>
                        <li>HOWEVER, <strong>when an array is passed into a function, the actual array is passed.</strong>.
                            Hence, modifying the elements of array inside the function will also affect the original argument which is
                            out of the function.</li>
                    </ul>
                <li>The std::swap() function from C++ standard librar can be used for swapping elements of array as well.</li>
                <li>To sort elements of array, we can use the std::sort() function in &lt;alogrithm> library.</li>
                    <pre>
                        <code>
    int array[]&#123; 10, 1, 22, 31, 5, 8, 3, 21 };
    std::sort(std::begin(array), std::end(array));
                        </code>
                    </pre>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Vector</h3>
            <ul>
                <li>std::vector provides dynamic array functionality that handles its own memory management.</li>
                        <li>This means you can create arrays that have their length set at run-time,
                             without having to explicitly allocate and deallocate memory using <span class="highlightInGrey">new</span> and <span class="highlightInGrey">delete</span>.
                             This is because std::vector will dynamically allocate memory for its contents as requested.</li>
                <li>Vector declaration example:</li>
                    <pre>
                        <code>
    std::vector&lt;int> arrayC; // no need to specify length at the declaration
    std::vector&lt;int> arrayD(5); // using direct initialization, we can create a vector with specific number of elements,
    std::vector&lt;int> arrayE = &#123; 9, 7, 5, 3, 1 }; // use initializer list to initialize array (Before C++11)
    std::vector&lt;int> arrayF&#123; 9, 7, 5, 3, 1 }; // use uniform initialization to initialize array
    int n = 5;
    std::vector&lt;int> testV(n, -1); // direct initialization with run-time length, and initialize all the elements to -1
    for (const auto num : testV) &#123;
        std::cout &lt;&lt; num &lt;&lt; ' '; // output: -1 -1 -1 -1 -1
    }
                        </code>
                    </pre>
                <li>size() vs capacity()</li>
                    <ul>
                        <li>size() shows how many items in the vector</li>
                        <li>capacity() shows how many items the vector can fit, when we push_back() more than that, reallocatin will
                            happen and the capacity() will be doubled
                        </li>
                    </ul>
                <li>reserve() vs resize()</li>
                    <ul>
                        <li>reserve() only does allocation of memory, only changes the capacity</li>
                        <li>resize() does both allocation and instance creation, and this changes both size and capacity</li>
                        <li>Look at the code snippet below for better understanding:</li>
                            <pre>
                                <code>
    std::cout&lt;&lt;"===== v1 =====\n";
    std::vector&lt;int> v1;
    v1.resize(10); //allocation + instance creation

    std::cout &lt;&lt; v1.size() &lt;&lt; std::endl;     //prints 10, already 10 items in the vector
    std::cout &lt;&lt; v1.capacity() &lt;&lt; std::endl; //prints 10

    // Since there are already 10 items in the vector, we should modify the elements instead of push_back
    for (int i = 0; i &lt; 10; ++i) v1[i] = 999999;

    std::cout&lt;&lt;"===== v2 =====\n";
    std::vector&lt;int> v2;
    v2.reserve(10); //only allocation

    std::cout &lt;&lt; v2.size() &lt;&lt; std::endl;     //prints 0, still no item in the vector
    std::cout &lt;&lt; v2.capacity() &lt;&lt; std::endl; //prints 10

    // Since there is no items in the vector, we can only push_back()
    for (int i = 0; i &lt; 10; ++i) v2.push_back(999999);

    std::cout&lt;&lt;"===== v3 =====\n";
    std::vector&lt;int> v3;
    v3.reserve(10); //only allocation

    std::cout &lt;&lt; v3.size() &lt;&lt; std::endl;     //prints 0, still no item in the vector
    std::cout &lt;&lt; v3.capacity() &lt;&lt; std::endl; //prints 10

    // What if we append 11 items?
    for (int i = 0; i &lt; 11; ++i) v3.push_back(999999);

    std::cout &lt;&lt; v3.size() &lt;&lt; std::endl;     //prints 11
    std::cout &lt;&lt; v3.capacity() &lt;&lt; std::endl; //prints 20, capacity is doubled when reallocation happens
                                </code>
                            </pre>
                    </ul>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Pointer</h3>
            <ul>
                <li>The <strong>address-of operator (&)</strong> allows us to see what memory address is assigned to a variable.</li>
                <li>The <strong>indirection operator (*)</strong> (also called <strong>dereference operator</strong>) allows us to access the value at a particular address:</li>
                <li>A <strong>pointer</strong> is a variable that holds a memory address as its value.</li>
                    <pre>
                        <code>
    int x&#123; 5 };
    int* ptrX&#123;&x}; // initialize ptrX with address of vqriable x
    std::cout &lt;&lt; x &lt;&lt; '\n'; // print the value of variable x
    std::cout &lt;&lt; &x &lt;&lt; '\n'; // print the memory address of variable x
    std::cout &lt;&lt; ptrX &lt;&lt; '\n'; // print the address that ptrX is holding
    std::cout &lt;&lt; *(&x) &lt;&lt; '\n'; /// print the value at the memory address of variable x (parenthesis is optional)                            
                        </code>
                    </pre>
            </ul>
        </div>
        <mat-divider></mat-divider>
        
        <div>
            <h3>New & Delete</h3>
            <ul>
                <li>C++ supports 3 basic types of memory allocation</li>
                <ul>
                    <li><strong>Static memory allocation</strong> happens for static and global variables.
                        Memory for these types of variables is allocated once when your program is run and persists throughout the life of your program.</li>
                    <li><strong>Automatic memory allocation</strong> happens for function parameters and local variables.
                        Memory for these types of variables is allocated when the relevant block is entered, and freed when the block is exited, as many times as necessary.</li>
                    <li><strong>Dynamic memory allocation</strong> is a way for running programs to request memory from the operating system when needed. 
                        This memory does not come from the program’s limited stack memory -- instead, it is allocated from a much larger pool of memory managed by the operating system called the <strong>heap</strong>. 
                        On modern machines, the heap can be gigabytes in size.</li>
                </ul>
            <li>Both static and automatic allocation have two things in common:</li>
                <ul>
                    <li>The size of the variable / array must be known at compile time.</li>
                    <li>Memory allocation and deallocation happens automatically (when the variable is instantiated / destroyed).</li>
                </ul>
            <li>Dynamically allocating single variables</li>
                <ul>
                    <li>To allocate a single variable dynamically, we use the scalar (non-array) form of the new operator. The new operator creates the object using that memory, and then returns a pointer containing the address of the memory that has been allocated.</li>
                        <pre>
                            <code>
int* ptr&#123; new int }; // dynamically allocate an integer and assign the address to ptr so we can access it later
*ptr = 7; // assign value of 7 to allocated memory

int* ptr2&#123; new int &#123; 6 } }; // use uniform initialization
                            </code>
                        </pre>
                </ul>
            <li>When you dynamically allocate memory,</li>
                <ul>
                    <li>You’re asking the operating system to reserve some memory for your program’s use.</li>
                    <li>If it can fulfill this request, it will return the address of that memory to your application.</li>
                    <li>From that point forward, your application can use this memory as it wishes. </li>
                    <li>When your application is done with the memory, it can return the memory back to the operating system to be given to another program.</li>
                </ul>
            <li>You may free a memory for reuse by using the <strong>delete</strong> operator.
                 Note that the delete operator doesn't actually delete anything, it simply returns the memory being pointed to back to the operating system.
                However, after freeing the memory, remember to set the pointer to nullptr.</li>
                <pre>
                    <code>
// assume ptr has previously been allocated with operator new
delete ptr; // return the memory pointed to by ptr to the operating system
ptr = nullptr; // set ptr to be a null pointer
                    </code>
                </pre>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Memory Leaks</h3>
            <ul>
                <li>Dynamically allocated memory stays allocated until it is explicitly deallocated or until the program ends.</li>
                <li>However, the pointers used to hold dynamically allocated memory addresses follow the normal scoping rules for local variables.</li>
                <li>Consider the following:</li>
                    <pre>
                        <code>
    void doSomething() &#123;
        int* ptr&#123; new int&#123;} };
    }
                        </code>
                    </pre>
                <li>Because pointers variables are just normal variables, when the function ends, ptr will go out of scope.</li>
                <li>Then, ptr is destroyed there are no more references to the dynamically allocated memory.</li>
                <li>Now, the memory address is allocated but now we dont have any reference to that memory address, and hence we can't free the memory address.</li>
                <li>This is called a <strong>memory leak</strong>, which means your program loses the address of some bit of dynamically allocated memory before giving it back to the operating system. </li>
                <li>Memory leaks will eat up your free memory while the program is running.</li>
                <li>The following 2 cases will also result in memory leaks:</li>
                    <pre>
                        <code>
    // CASE 1 - a pointer is assigned another value
    int value = 5;
    int* ptr&#123; new int&#123;} }; // allocate memory
    ptr = &amp;value; // old address lost, memory leak results

    // CASE 2 - double-allocation
    int* ptr&#123; new int&#123;} };
    ptr = new int&#123;}; // old address lost, memory leak results
                            </code>
                        </pre>
                <li>The solution for memory leaks would be deleting or freeing the pointer before it is out of scope or before assigning new value to it.</li>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Homogeneous & Heterogeneous Containers</h3>
            <ul>
                <li>A container is an object holding instances of another object.</li>
                <li>A container that contains or holds objects of a single type is said to be <b>homogenous</b>.</li>
                <li>A container that contains objects (derived from a common base class) of a variety of types is termed <b>heterogeneous</b></li>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>Returning multiple values from a function</h3>
            <ul>
                <li>C++ does not have an official way to return multiple values from a function.</li>
                <li>However, we can make use of std::pair, std::tuple or struct to return multiple values.</li>
                <li>For example,</li>
                <pre>
                    <code>
    #include &lt;tuple>

    tuple&lt;int, float, string> sampleFunc()
    &#123;
        return &#123;123, 3.142, "Hello World"};
    }

    int main() 
    &#123;
        auto [value1, value2, value3] = sampleFunc(); // C++ 17 needed
        return 0;
    }
                    </code>
                </pre>
                <li>More properly, std::make_tuple should be used to pack the variables into tuple: </li>
                    <pre>
                        <code>
    std::make_tuple(123, 3.142, "Hello World");
                        </code>
                    </pre>
                <li>On the other hand, std::tie can be used to unpack a tuple into variables:</li>
                    <pre>
                        <code>
    std::tie (value1, value2, value3) = sampleFunc();
                        </code>
                    </pre>
            </ul>
        </div>
        <mat-divider></mat-divider>

    </div>
</div>