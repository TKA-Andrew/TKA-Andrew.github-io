<div class="flexContainer">
    <div>
        <div>
            <h1>Python Notes</h1>
            <h2>Introduction</h2>
            <ul>
                <li>Assuming python basics are easy and common, the basics notes are not included here.</li>
            </ul>
        </div>
        <mat-divider></mat-divider>

        <div>
            <h3>getattr(), setattr(), hasattr(), delattr()</h3>
            <ul>
                <li>getattr(object, attribute, default)</li>
                <li>setattr(object, attribute, value)</li>
                <li>hasattr(object, attribute)</li>
                <li>delattr(object, attribute)</li>
            </ul>
            <mat-divider></mat-divider>
        </div>

        <div>
            <h3>classmethod() , @classmethod</h3>
            <ul>
                <li>Class methods can be called by both class and object.</li>
                <li>Class methods can also be used to do something like multiple constructors of C++.</li>
                <li>Take note that class methods take 'cls' as the first parameter instead of 'self'</li>
                <li>cls vs self:</li>
                    <ul>
                        <li>cls refers to the class, whereas self refers to the instance. </li>
                        <li>Using the cls keyword, we can only access the members of the class, whereas using the self keyword, we can access both the instance variables and the class attributes.</li>
                    </ul>
                <li>Code snippet example:</li>
                    <pre>
                        <code>
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
  
    # a class method to create a Person object by birth year.
    @classmethod
    def fromBirthYear(cls, name, year):
        return cls(name, date.today().year - year)
    
    def displayHelloWorld():
        print("Hello World!")

# Make the displayHelloWorld as a classmethod
Person.displayHelloWorld = classmethod(Person.displayHelloWorld)
Person.displayHelloWorld() # Now the function can be called directly without instantiation of object
abc = Person('abc', 10) # Instantiation of object using default __init__()
xyz = Person.fromBirthYear('xyz', 1997) # Instantiation of object using fromBirthYear()
                        </code>
                    </pre>
            </ul>
            <mat-divider></mat-divider>
        </div>

        <div>
            <h3>@cached_property</h3>
            <ul>
                <li>The cached_property is a decorator provided by the functools module in Python.</li>
                <li>The @cached_property decorator transforms a method of a class into a property.</li>
                <li>When accessed, the property's value is computed only once and then cached as a 
                    normal attribute.</li>
                <li>It is important to note that cached_property is suitable for use when the dependent
                    attribute is constant, as the computation is only performed once.</li>
                <li>Example:
                    <pre>
                        <code>
from functools import cached_property


class MiscMath:
    def __init__(self, number):
        self.number = number
    
    @cached_property
    def squared(self):
        print(f"Calculating squared of &#123;self.number} ...")
        return self.number ** 2
                        </code>
                    </pre>

                </li>
            </ul>
            <mat-divider></mat-divider>
        </div>

        <div>
            <h3><b>from __future__ import absolute_import</b> and <b>from __future__ import unicode_literals</b></h3>
            <ul>
                <li>This 2 imports are needed if you want your code to be compatible with both Python 2.x and Python 3.x</li>
                <li>They are not needed in Python 3.x as the behaviors they enable are already the default.</li>
                <li>from __future__ import absolute_import</li>
                    <ul>
                        <li>This import statement is used in Python 2.x to enable the behavior of absolute imports, 
                            which is the default import behavior in Python 3.x.</li>
                        <li>In Python 2.x, when you have a package with submodules and you use relative imports within that package, 
                            there can be ambiguity if there is a module with the same name as a submodule in another package. Absolute imports help avoid this ambiguity.</li>
                    </ul>
                <li>from __future__ import unicode_literals</li>
                    <ul>
                        <li>This import statement is used in Python 2.x to enable the behavior of treating string literals as Unicode by default, 
                            similar to Python 3.x.</li>
                        <li>In Python 2.x, string literals are treated as ASCII by default, which can lead to issues when working with Unicode characters and strings.</li>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div>

        <div>
            <h3>Python Dictionary get() method</h3>
            <ul>
                <li>When accessing a value of a Python Dictionary, using the get() function instead of the [] operator can be beneficial in certain situations to handle 
                    the absence of a key without raising a KeyError exception.
                </li>
                <li>Example:
                    <pre>
                        <code>
sample_dict = &#123;
    'a': 123,
    'b': 'abc'
}

try:
    print(sample_dict['c'])
except KeyError as e:
    print("Key error exception!")

print(sample_dict.get('c', None))  # Returns None
                        </code>
                    </pre>
                </li>
            </ul>
            <mat-divider></mat-divider>
        </div>
    </div>
</div>