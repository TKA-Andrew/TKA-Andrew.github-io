<div class="flexContainer">    
    <div fxLayout="column" fxLayoutGap="10px">
        <h1>Dijsktra's Algorithm</h1>
        <div>
            <h2>Introduction</h2>
            <ul>
                <li>Dijsktra's algorithm is an algorithm for finding the shortest path between the nodes in a path.</li>
                <li>There are 2 variants of Dijsktra's Algorithm</li>
                    <ul>
                        <li>Original variant: With starting point and destination defined, find the shortest path/distance from between this 2 points</li>
                        <li>Another variant: With starting point defined, find the shortest path from start to all vertices</li>
                    </ul>
                <li>Excellent Youtube videos</li>
                    <ul>
                        <li><a href="https://www.youtube.com/watch?v=EFg3u_E6eHU" target="_blank" ref="noopener noreferrer">Overview</a></li>
                        <li><a href="https://www.youtube.com/watch?v=pLElbKBc4RU&t=0s" target="_blank" ref="noopener noreferrer">Dijsktra's Algorithm walkthrough</a></li>
                        <li><a href="https://www.youtube.com/watch?v=OHJpOGa_L34" target="_blank" ref="noopener noreferrer">LeetCode Questions walkthrough</a></li>
                    </ul>
                <li>If the problem has the following characteristics, it is most likely can be solved using Dijsktra's algorihm:</li>
                    <ul>
                        <li>There is a starting point</li>
                        <li>Finding minimum path (can be maximum also, see LeetCode1514) with the starting point as reference</li>
                    </ul>
                <li>There are a few things to take note:</li>
                    <ul>
                        <li>Are the edges directed or undirected?</li>
                            <ul>
                                <li>This will determine whether our graphs variable need to store 2 way direction info</li>
                                
                            </ul>
                        <li>Is there any negative edge?</li>
                            <ul>
                                <li>If yes, we need to consider other algorithms such as Bellman-Fordâ€™s algorithm</li>
                            </ul>
                        <li>Is the problem asking for path or only distance?</li>
                            <ul>
                                <li>If path is needed, we need to keep track the previous vertex when we update
                                    the minDistances vector.
                                </li>
                            </ul>
                    </ul>
                <li><b>Algorithm according to first video</b></li>
                    <ol>
                        <li>Construct a <span style="font-style: italic;">graph</span> variable</li>
                            <ul>
                                <li>Need to take note whether graph is directed or undirected.</li>
                                <li>Example of undirected graph construction:</li>
                                    <pre>
                                        <code>
    // GIVEN edges = [[1,2,1],[2,3,2],[1,3,1]]; 
    // where each element represents &#123;source, destination, travelCost}

    typedef std::unordered_map&lt;int,std::vector&lt;std::pair&lt;int, int>>> Graph;

    // GRAPH CONSTRUCTION
    Graph graph;
    for(int i=0; i&lt;edges.size(); i++) &#123;
        graph[edges[i][0]].push_back(&#123;edges[i][1],edges[i][2]});
        graph[edges[i][1]].push_back(&#123;edges[i][0],edges[i][2]}); // if the graph is undirected
    }
                                        </code>
                                    </pre>
                            </ul>
                        <li>Declare a <span style="font-style: italic;">minTravelCost</span> vector</li>
                            <ul>
                                <li>To keep track minimum Travel cost from starting point to thre rest of the vertices</li>
                            </ul>
                        <li>Declare a <span style="font-style: italic;">visited</span> std::set</li>
                            <ul>
                                <li>To keep track the vertices that have been visited</li>
                            </ul>
                        <li>Declare one more vector called <span style="font-style: italic;">prev</span> if needed to keep track the shortest path</li>
                        <li><span class="script-font">minTravelCost[startingPoint] = 0</span></li>
                        <li>While not all vertices visited</li>
                            <ul>
                                <li>Find unvisited vertex with minimum travel cost among the rest of unvisited vertices</li>
                                <li>Add that <span style="font-style: italic;">curVertex</span> into visited std::set</li>
                                <li>Foreach neighbouring vertices:</li>
                                    <ul>
                                        <li>If visited, continue</li>
                                        <li>Calculate <span style="font-style: italic;">newTravelCost</span></li>
                                        <li>If <span style="font-style: italic;">newTravelCost</span> is lower than <span style="font-style: italic;">minTravelCost[curVertex]</span></li>
                                            <ul>
                                                <li><span class="script-font">minTravelCost[curVertex] = newTravelCost;</span></li>
                                                <li><span class="script-font">prev[nextVertex] = curVertex;</span></li>
                                            </ul>
                                    </ul>
                            </ul>
                    </ol>
                <li><b>Algorithm according to second video</b>, the following my modified version:</li>
                    <ul>
                        <li><b>Original Variant</b> (with starting point and destination defined)</li>
                            <pre>
                                <code>
    typedef std::priority_queue &lt;std::pair&lt;int, int>, std::vector&lt;std::pair&lt;int, int>>, std::greater&lt;std::pair&lt;int, int>>> MinHeap;

    std::pair&lt;int, std::vector&lt;int>> dijkstraSingleTarget(Graph& graph, int source, int target, int n) &#123;
    
        MinHeap minHeap;
        
        // VARIABLLE DECLARATION
        std::vector&lt;int> minTravelCost(n, INT_MAX);
        std::vector&lt;int> prev(n, -1);
        std::vector&lt;bool> visited(n, false);

        // BASE CASE
        minTravelCost[source] = 0;
        
        minHeap.push(&#123;0, source});
        
        while (!minHeap.empty()) &#123;
            auto [curTravelCost, curVertex] = minHeap.top();
            minHeap.pop();
            if (curVertex == target) &#123;
                break;
            }
            if (visited[curVertex]) &#123;
                continue;
            }
            visited[curVertex] = true;
            for (const auto& [nextVertex, nextTravelCost]: graph[curVertex]) &#123;
                int newTravelCost = curTravelCost + nextTravelCost;
                if (!visited[nextVertex] && newTravelCost&lt;minTravelCost[nextVertex]) &#123;
                    minTravelCost[nextVertex] = newTravelCost;
                    prev[nextVertex] = curVertex;
                    minHeap.push(&#123;newTravelCost, nextVertex});
                }
            }
            
        }
        return &#123;minTravelCost[target], prev};
        
    }
                                </code>
                            </pre>
                        <li><b>Another variant</b> (with only starting point defined)</li>
                            <pre>
                                <code>
    typedef std::priority_queue &lt;std::pair&lt;int, int>, std::vector&lt;std::pair&lt;int, int>>, std::greater&lt;std::pair&lt;int, int>>> MinHeap;
    
    std::pair&lt;std::vector&lt;int>, std::vector&lt;int>> dijkstra(Graph& graph, int source, int n) &#123;
        
        MinHeap minHeap;
        
        // VARIABLLE DECLARATION
        std::vector&lt;int> minTravelCost(n, INT_MAX);
        std::vector&lt;int> prev(n, -1);
        std::vector&lt;bool> visited(n, false);

        // BASE CASE
        minTravelCost[source] = 0;
        
        minHeap.push(&#123;0, source});
        
        while (!minHeap.empty()) &#123;
            auto [curTravelCost, curVertex] = minHeap.top();
            minHeap.pop();
            if (visited[curVertex]) &#123;
                continue;
            }
            visited[curVertex] = true;
            for (const auto& [nextVertex, nextTravelCost]: graph[curVertex]) &#123;
                int newTravelCost = curTravelCost + nextTravelCost;
                if (!visited[nextVertex] && newTravelCost&lt;minTravelCost[nextVertex]) &#123;
                    minTravelCost[nextVertex] = newTravelCost;
                    prev[nextVertex] = curVertex;
                    minHeap.push(&#123;newTravelCost, nextVertex});
                }
            }
            
        }
        return &#123;minTravelCost, prev};
        
    }
                                </code>
                            </pre>
                    </ul>
            </ul>
            <mat-divider></mat-divider>
        </div>

        <div>
            <h2>List of Dijsktra's LeetCode Questions</h2>
            <ul>
                <li><a href="https://leetcode.com/problems/network-delay-time/" target="_blank" rel="noopener noreferrer">
                    [medium] 743. Network Delay Time</a></li>    
                <li><a href="https://leetcode.com/problems/path-with-maximum-probability/" target="_blank" rel="noopener noreferrer">
                    [medium] 1514. Path with Maximum Probability</a></li>
                <li><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/" target="_blank" rel="noopener noreferrer">
                    [medium] 787. Cheapest Flights Within K Stops</a></li>
                <li><a href="https://leetcode.com/problems/path-with-minimum-effort/" target="_blank" rel="noopener noreferrer">
                    [medium] 1631. Path With Minimum Effort</a></li>
                <li><a href="https://leetcode.com/problems/swim-in-rising-water/" target="_blank" rel="noopener noreferrer">
                    [hard] 778. Swim in Rising Water</a></li>
                <!-- <li><a href="https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/" target="_blank" rel="noopener noreferrer">
                    [medium] 1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance</a></li> -->
            </ul>
        </div>

        <div>
            <h3>LeetCode 743. Network Delay Time</h3>
            <ul>
                <li>The following is the simple solution which is not yet optimized using priority queue, but sufficient for 
                    demonstrating Dijsktra's Algorithm.
                </li>
                    <pre>
                        <code>
    #include &lt;vector>
    #include &lt;set>
    #include &lt;unordered_map>
    #include &lt;climits>
    
    class Solution &#123;
    public:
        int networkDelayTime(std::vector&lt;std::vector&lt;int>>& times, int n, int k) &#123;
    
            // VARIABLLE DECLARATION
            std::vector&lt;int> minTravelCost(n, INT_MAX);
            std::set&lt;int> visited;
    
            // BASE CASE
            minTravelCost[k-1] = 0;
            
            // GRAPH CONSTRUCTION
            std::unordered_map&lt;int,std::vector&lt;std::pair&lt;int, int>>> graph;
            for(int i=0; i&lt;times.size(); i++)&#123;
                graph[times[i][0]].push_back(&#123;times[i][1],times[i][2]});
            }
            
            // LOOP UNTIL ALL VERTICES ARE VISITED
            while (visited.size() != n) &#123;
    
                // FIND UNVISITED VERTEX WITH MINIMUM TRAVEL COST
                auto [curretnVertex, currentMinTravelCost] = getVertexWithMinTravelCost(minTravelCost, visited);
    
                // ENDING CONDITION
                if (currentMinTravelCost == INT_MAX) &#123;
                    return -1;
                }
    
                // UPDATE VISITED VERTICES
                visited.insert(curretnVertex);
    
                // SCAN THROUGH NEIGHBOURING VERTICES
                for (auto edgeInfo: graph[curretnVertex]) &#123;
                    int vertexIdx = edgeInfo.first;
                    if (visited.find(vertexIdx) != visited.end()) &#123;
                        continue;
                    }
                    
                    // FORMULATE newTravelCost
                    int newTravelCost = currentMinTravelCost + edgeInfo.second;
    
                    // UPDATE minTravelCost
                    if (newTravelCost&lt;minTravelCost[vertexIdx-1]) &#123;
                        minTravelCost[vertexIdx-1] = newTravelCost;                
                    }
                }
            }
    
            int maxTime = -1;
            for (auto time:minTravelCost) &#123;
                maxTime=std::max(maxTime, time);
            }
    
            return maxTime;
        }
        
        std::tuple&lt;int, int> getVertexWithMinTravelCost(const std::vector&lt;int>& minTravelCost, const std::set&lt;int>& visited)
        &#123;
            int currentMinTravelCost = INT_MAX;
            int vertex = -1;
            for (int vertexIdx = 1; vertexIdx&lt;minTravelCost.size()+1; vertexIdx++) &#123;
                int time = minTravelCost[vertexIdx-1];
                if (visited.find(vertexIdx) != visited.end()) &#123;
                    continue;
                }
                if (time &lt; currentMinTravelCost) &#123;
                    currentMinTravelCost = time;
                    vertex = vertexIdx;
                }
            }
            return &#123;vertex, currentMinTravelCost};
        }
    };
                        </code>
                    </pre>
                <li>The following is the optimized solution with the help of MinHeap:</li>
                    <pre>
                        <code>
    #include &lt;vector>
    #include &lt;queue>
    #include &lt;unordered_map>
    #include &lt;climits>

    typedef std::priority_queue &lt;std::pair&lt;int, int>, std::vector&lt;std::pair&lt;int, int>>, std::greater&lt;std::pair&lt;int, int>>> MinHeap;

    typedef std::unordered_map&lt;int,std::vector&lt;std::pair&lt;int, int>>> Graph;

    class Solution &#123;
    public:
        
        std::vector&lt;int> dijkstra(Graph& graph, int source, int n) &#123;
            MinHeap minHeap;
            
            // VARIABLLE DECLARATION
            std::vector&lt;int> minTravelCost(n, INT_MAX);
            std::vector&lt;bool> visited(n, false);

            // BASE CASE
            minTravelCost[source] = 0;
            
            minHeap.push(&#123;0, source});
            
            while (!minHeap.empty()) &#123;
                auto [curTravelCost, curVertex] = minHeap.top();
                minHeap.pop();
                if (visited[curVertex]) &#123;
                    continue;
                }
                visited[curVertex] = true;
                for (const auto& [nextVertex, nextTravelCost]: graph[curVertex]) &#123;
                    int newTravelCost = curTravelCost + nextTravelCost;
                    if (!visited[nextVertex] && newTravelCost&lt;minTravelCost[nextVertex]) &#123;
                        minTravelCost[nextVertex] = newTravelCost;
                        minHeap.push(&#123;newTravelCost, nextVertex});
                    }
                }
                
            }
            return minTravelCost;
            
        }
        
        int networkDelayTime(std::vector&lt;std::vector&lt;int>>& times, int n, int k) &#123;
            
            // GRAPH CONSTRUCTION
            Graph graph;
            for(int i=0; i&lt;times.size(); i++)&#123;
                graph[times[i][0]-1].push_back(&#123;times[i][1]-1,times[i][2]});
            }
            
            auto minTravelCost = dijkstra(graph, k-1, n);
            
            int maxTime = -1;
            for (auto time:minTravelCost) &#123;
                if (time == INT_MAX) &#123;
                    return -1;
                }
                if (time > maxTime) &#123;
                    maxTime = time;
                }
            }
            
            return maxTime;
        }
        
    };
                        </code>
                    </pre>
            </ul>
        </div>

        <!-- <div>
            <h3>LeetCode 1514. Path with Maximum Probability</h3>
            <ul>
                <li>The question is a typical original variant Dijsktra's Alogrithm question, except that it finds maximum instead of 
                    instead of minimum.
                </li>
                <li>The following is the straight forward solution, but with "Time Limit Exceeded" issue when submitted on LeetCode.</li>
                    <pre>
                        <code>
                            
                        </code>
                    </pre>
            </ul>
        </div> -->
    </div>
</div>