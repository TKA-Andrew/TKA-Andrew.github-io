<div class="flexContainer">
    <mat-accordion displayMode="flat" style="padding-left: 5px; padding-right: 5px;">
        <mat-expansion-panel style="margin-top: 5px;">
            <mat-expansion-panel-header>
                <mat-panel-title>
                    Fundamental
                </mat-panel-title>
            </mat-expansion-panel-header>
            <button mat-button class="listItem" (click)="scrollTo('complexityAnalysis')">Complexity Analysis</button>
            <button mat-button class="listItem" (click)="scrollTo('memory')">Memory</button>
            <button mat-button class="listItem" (click)="scrollTo('bigONotation')">Big O Notation</button>
            <button mat-button class="listItem" (click)="scrollTo('arrays')">Arrays</button>
            <button mat-button class="listItem" (click)="scrollTo('linkedLists')">Linked Lists</button>
            <button mat-button class="listItem" (click)="scrollTo('hashTables')">Hash Tables</button>
            <button mat-button class="listItem" (click)="scrollTo('stacksAndQueues')">Stacks & Queues</button>
            <button mat-button class="listItem" (click)="scrollTo('strings')">Strings</button>
            <button mat-button class="listItem" (click)="scrollTo('graphs')">Graphs</button>
        </mat-expansion-panel>
    </mat-accordion>
    <div fxLayout="column" fxLayout="column">
        <div>
            <h1>Algo Expert Fundamental</h1>
            <h2>Introduction</h2>
            <p>These are my personal notes when I go through the <a href="https://www.algoexpert.io/product" target="_blank" rel="noopener noreferrer">AlgoExpert course</a>.</p>
            <p>These are just short notes, the course is recommended as there are some great explanations for different algorithm questions.</p>
            <p>However, for alternative option, you may proceed with <a href="https://leetcode.com/" target="_blank" rel="noopener noreferrer">LeetCode</a>.</p>
            <mat-divider></mat-divider>
        </div>
        <div id="complexAnalysis">
            <h2>Complexity Analysis</h2>
            <p>Commonly there are more than one solution to a problem. And how do we determine which one is better?
                Through complexity analysis. The worse solutions normally have needless complexity. There are 2 types of complexity, time complexity and space complexity. You can refer to them together as space-time complexity as well.</p>
            <p>Time complexity is a measure of how fast an algorithm or solution runs.</p>
            <p>Space complexity is a measure of how much memory or space an algorithm uses up.</p>
            <mat-divider></mat-divider>
        </div>
        <div id="memory">
            <h2>Memory</h2>
            <p>There are few things that you need to know:</p>
            <ul>
                <li>There are limited memory in each computer</li>
                <li>The data are stored in bytes ( 8 bits = 1 byte)</li>
                <li>Int is 32-bit integer and Long is 64-bit integer, and these are called fixed-width integers</li>
                <li>Hence, the memory taken up by the integers are fixed, depending on their data type, not their value</li>
                <li>The idea of pointer is you record the memory address of another memory slot in a memory slot</li>
            </ul>
            <mat-divider></mat-divider>
        </div>
        <div id="bigONotation">
            <h2>Big O Notation</h2>
            <p>Big O Notation is a notation used to describe the time complexity and space complexity of an algorithm.
                For time complexity, it is not logical to exactly describe the speed of an algorithm with the unit of milliseconds or seconds,
                as the execution time is affected by many factors such as programs running in the background or even processing ability of your CPU.</p>
            <p>Hence, to describe time complexity, we usually describe how fast an algorithm runs as the input size increases.
                This is because different algorithms have different processing speeds when the input size is different.
                Hence, we describe them with a notation, without any SI unit.</p>
            <p>The following are some common examples of complexities and their Big O Notations (ordered from fastest to slowest):</p>
            <ul>
                <li>Constant: O(1)</li>
                <li>Logarithmic: O(log(n))</li>
                <li>Linear: O(n)</li>
                <li>Log-Linear: O(nlog(n))</li>
                <li>Quadaratic: O(n^2)</li>
                <li>Cubic: O(n^3)</li>
                <li>Exponential: O(2^n)</li>
                <li>Factorial: O(n!)</li>
            </ul>
            <mat-divider></mat-divider>
        </div>
        <div id="arrays">
            <h2>Arrays</h2>
            <p>There are two types of arrays: Static Array & Dynamic Array. </p>
            <p>In C++ or Java, when you declare an array, you need to specify the length of the array.
                On the other hand, in Python or Javascript, you do not need to specify the length of an array.</p>
            <p>The follwing are some array's standard operations and their corresponding time complexities:</p>
            <table>
                <tr>
                    <th>Operation</th>
                    <th>Time Complexity</th>
                    <th>Space Complexity</th>
                </tr>
                <tr>
                    <td>Accessing a value at a given index</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Updating a value at a given index</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Inserting a value at the beginning</td>
                    <td>O(n)</td>
                    <td>
                        <div><span>Dynamic Array: O(1) or O(n)</span></div>
                        <div><span>Staticc Array: O(1)</span></div>
                    </td>
                </tr>
                <tr>
                    <td>Inserting a value in the middle</td>
                    <td>O(n)</td>
                    <td>
                        <div><span>Dynamic Array: O(1) or O(n)</span></div>
                        <div><span>Static Array: O(1)</span></div>
                    </td>
                </tr>
                <tr>
                    <td>Inserting a value at the end</td>
                    <td>
                        <div><span>Dynamic Array: O(1) or O(n)</span></div>
                        <div><span>Static Array: O(n)</span></div>
                    </td>
                    <td>
                        <div><span>Dynamic Array: O(1) or O(n)</span></div>
                        <div><span>Static Array: O(1)</span></div>
                    </td>
                </tr>
                <tr>
                    <td>Removing a value at the beginning</td>
                    <td>O(n)</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Removing a value in the middle</td>
                    <td>O(n)</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Removing a value at the end</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Copying the array</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td>Traversing the array</td>
                    <td>O(n)</td>
                    <td>O(1)</td>
                </tr>
            </table>
            <p>Side Notes:</p>
            <ul>
                <li>For Dynamic Array, time complexity of inserting a value at the end will take O(1) if it has enough
                    memory slots. Else, it will take O(n)+ time complexity, which also called 
                    <a href="https://medium.com/@satorusasozaki/amortized-time-in-the-time-complexity-of-an-algorithm-6dd9a5d38045" target="_blank" rel="noopener noreferrer">Armotized O(1)</a>.
                </li>
                <li>The space complexity for inserting value in Dynamic Array is also depending on whether it has enough memory slots.</li>
                <li>However, for Static Array, everytime when an additional value is inserted, the array will be copied
                    and relocated to new memory slots. This is because it is not guaranteed that the subsequent memory slots are available for expanding the array. 
                    After copying, the previous memory slots will be free, hence resulting in O(1) space complexity.
                </li>
            </ul>
            <mat-divider></mat-divider>
        </div>
    </div>
    <div id="linkedLists">
        <h2>Linked Lists</h2>
        <p>Linked list is quite similar to an array, except that it has pointers between each element.</p>
        <p>There are 2 common types of linked lists: Singly Linked List & Doubly Linked List.</p>
        <ul>
            <li>Each node of a Singly Linked List is a node (class) with <span style="font-style: italic;">value</span> and <span style="font-style: italic;">next</span> properties.
                The first node is called <span style="font-style: italic;">head</span>, whereas the last node which has the <span style="font-style: italic;">next</span> property points to a null value is called <span style="font-style: italic;">tail</span>.</li>
            <li>Each node of a Doubly Linked List has two pointers, one pointing to the previous node and another one pointing to the next node.</li>
        </ul>
        <pre>
            <code>
// Singly Linked List example
1 -> 4 -> 3 -> 8 -> 3 -> null

// Doubly Linked List example
null &lt;- 2 &lt;-> 5 &lt;-> 3 &lt;-> 6 &lt;-> null
            </code>
        </pre>
        <p>Other than that, the way a linked list is stored in memory is different from an array. Unlike arrays, linked lists are not stored back-to-back. Because of this, some operations in linked lists are faster than arrays.
            The time complexities of these operations also depend on whether the linked lists have the tail and head declared.</p>
        <table>
            <tr>
                <th>Operation</th>
                <th>Time Complexity</th>
                <th>Space Complexity</th>
            </tr>
            <tr>
                <td>Accessing the head</td>
                <td>O(1)</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>Accessing the tail</td>
                <td>O(1) if tail is defined; else O(n)</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>Accessing a middle node</td>
                <td>O(i), where i is the index of the node</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>Inserting/Removing the head</td>
                <td>O(1)</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>Inserting/Removing the tail</td>
                <td>O(1) if tail is defined; else O(n)</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>Inserting/Removing a middle node</td>
                <td>O(i), where i is the index of the node</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>Searching for a value</td>
                <td>O(n)</td>
                <td>O(1)</td>
            </tr>
        </table>
        <p>Another special linked list is circular linked list, which doesn't have clear "tail" and "head"</p>
        <mat-divider></mat-divider>
    </div>
    <div id="hashTables">
        <h2>Hash Tables</h2>
        <p>Hash Tables are basically key-value stores.</p>
        <p>A lot of modern programming languages have built-in hash tables. For example:</p>
        <ul>
            <li>Python - Dictionary</li>
            <li>Javascript - Object</li>
        </ul>
        <p>An example of hash table using Javascript Object:</p>
        <pre>
            <code>
// Javascript Object example
const monthRecord = &#123;
    'AUG': 8,
    'SEP': 9,
    'OCT': 10
}
            </code>
        </pre>
        <p>Under the hood, a hash table uses a Dynamic Array of Linked Lists to store the key-value pairs.</p>
        <p>When inserting a key-value pair, the <span style="font-style: italic">key</span> is hashed into an integer, 
            which will be used as index of the underlying dynamic array. Then, the <span style="font-style: italic">value</span>
            associated with the <span style="font-style: italic">key</span> will be added to the linked list stored at the index
            in the dynamic array. A reference to the <span style="font-style: italic">key</span> is also stored with that <span style="font-style: italic">value</span>.
        </p>
        <p>Hence, when there are multiple <span style="font-style: italic">keys</span> being hashed into a same integer, 
        the length of linked list at the integer will be longer.</p>
        <p>The example below shows the best case and worst case of hashing:</p>
        <pre>
            <code>
// BEST CASE
[
    0: (9, 'SEP') -> null
    1: (10, 'OCT') -> null
    2: (8, 'AUG') -> null
]

// WORST CASE
[
    0: (9, 'SEP') -> (10, 'OCT') -> (8, 'AUG') -> null
    1: null
    2: null
]
            </code>
        </pre>
        <p>However, in practice, we typically assume that the built-in hash functions are good enough to give us the best case 
            for most of the time. And with knowledge about time complexity for different operations in Linked List, we can say that:
        </p>
        The time complexity is O(1) on average; O(n) in the worse case for:
        <ul>
            <li>Inserting a key-value pair</li>
            <li>Removing a key-value pair</li>
            <li>Looking up a key</li>
        </ul>
        <mat-divider></mat-divider>
    </div>
    <div id="stacksAndQueues">
        <h2>Stacks And Queues</h2>
        <table>
            <tr>
                <th style="width: 50%">Stack</th>
                <th style="width: 50%">Queue</th>
            </tr>
            <tr>
                <td>An array-like data structure whose elements follow the Last In First Out (LIFO) rule</td>
                <td>An array-like data structure whose elements follow the First In First Out (FIFO) rule</td>
            </tr>
            <tr>
                <td>Similar to a stack of book, the last book will always be the first one to be removed from the stack.</td>
                <td>Similar to a group of people queueing to buy something, and the first one in the queue will be the first one 
                    to be served and get out of the queue.
                </td>
            </tr>
            <tr>
                <td>Typically implemented with a dynamic array or singly linked list</td>
                <td>Typically implemented with a doubly linked list</td>
            </tr>
        </table>
        <p>Both stack and queue have the same time complexity for the following operations,
            take note of the difference in naming used for "insert" and "remove" operations:</p>
        <table>
            <tr>
                <th>Stack</th>
                <th>Queue</th>
                <th>Time Complexity</th>
            </tr>
            <tr>
                <td>Pushing an element onto the stack</td>
                <td>Enqueueing an element into the queue</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>Popping an element off the stack</td>
                <td>Dequeueing an element out of the queue</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>Peeking at the element on the top of the stack</td>
                <td>Peeking at the element at the front of the queue</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>Searching for an element in the stack</td>
                <td>Searching for an element in the queue</td>
                <td>O(n)</td>
            </tr>
        </table>
        <p>The space complexity of the operations are basically O(1) space, except copying.</p>
        <mat-divider></mat-divider>
    </div>
    <div id="strings">
        <h2>Strings</h2>
        <p>Strings are implemented differently depending on the programming languages.</p>
        <p>Strings are basically an array of integers which are mapped to the characters of the string via character-enconding standard such as ASCII.</p>
        <table>
            <tr>
                <th>Operation</th>
                <th>Time Complexity</th>
                <th>Space Complexity</th>
            </tr>
            <tr>
                <td>Traverse a string</td>
                <td>O(n)</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>Copying a string</td>
                <td>O(n)</td>
                <td>O(n)</td>
            </tr>
            <tr>
                <td>Accessing a character at a given index</td>
                <td>O(1)</td>
                <td>O(1)</td>
            </tr>
        </table>
        <p>In most programming languages (except C++), strings are immutable, means they cannot be edited after creation.
            Hence, simple operations such as appending a character to a string is much expensivex than they might appear.
        This is because when we want to edit immutable strings, we are basically creating new strings.</p>
        <p>For example, if we want to add a string "def" after the immutable string "abc":</p>
        <pre>
            <code>
// example
string1 = 'abc';
string1 += 'def';

Space-Time complexity: O(n+m) where the n is due to copying the string and the m is due to adding of the 'def'
            </code>
        </pre>
        <p>Therefore, it is recommended to store string in the form of array of characters if possible.</p>
        <mat-divider></mat-divider>
    </div>
    <div id="graphs">
        <h2>Graphs</h2>
        <p>Graphs are collection of nodes that might or might not connected to one another. 
            The nodes are called <span style="font-style: italic;">vertices</span> and the arrows or connections between the vertices are called <span style="font-style: italic;">edges</span>.</p>
        <p>Some terms and definitions:</p>
        <table>
            <tr>
                <th>Term</th>
                <th>Definition</th>
            </tr>
            <tr>
                <td>Graph Cycle</td>
                <td>A closed loop formed by vertices</td>
            </tr>
            <tr>
                <td>Acyclic Graph</td>
                <td>A graph that has no cycles</td>
            </tr>
            <tr>
                <td>Cyclic Graph</td>
                <td>A graph that has at least one cycle</td>
            </tr>
            <tr>
                <td>Directed Graph</td>
                <td>A graph with directed edges, and can only be traversed in one direction</td>
            </tr>
            <tr>
                <td>Undirected Graph</td>
                <td>A graph with undirected edges, and can be traversed in both directions</td>
            </tr>
            <tr>
                <td>Connected Graph</td>
                <td>A graph that has one or more edges in every pair of vertices.</td>
            </tr>
        </table>
        <p>Two types of traversing method: Depth-first Search & Breadth-first Search</p>
        <p>Traversing the graph will need O(V+E) Space-Time Complexity, where V is number of vertices and E is number edges.</p>
        <mat-divider></mat-divider>
    </div>
</div>